/* Copyright (c) 2020, 2021, 2022 Vin√≠cius dos Santos Oliveira

   Distributed under the Boost Software License, Version 1.0. (See accompanying
   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) */

#include <iostream>
#include <new>

#include <boost/nowide/fstream.hpp>

#include <emilua/detail/core.hpp>
#include <emilua/dispatch_table.hpp>
#include <emilua/scope_cleanup.hpp>
#include <emilua/serial_port.hpp>
#include <emilua/async_base.hpp>
#include <emilua/byte_span.hpp>
#include <emilua/lua_shim.hpp>
#include <emilua/windows.hpp>
#include <emilua/stream.hpp>
#include <emilua/system.hpp>
#include <emilua/fiber.hpp>
#include <emilua/actor.hpp>
#include <emilua/mutex.hpp>
#include <emilua/regex.hpp>
#include <emilua/state.hpp>
#include <emilua/timer.hpp>
#include <emilua/cond.hpp>
#include <emilua/json.hpp>
#include <emilua/tls.hpp>
#include <emilua/ip.hpp>

#include <boost/predef/os/unix.h>
#include <boost/scope_exit.hpp>

#if __has_include(<experimental/memory>)
#include <experimental/memory>
#endif // __has_include(<experimental/memory>)

#if BOOST_OS_WINDOWS
#include <boost/nowide/iostream.hpp>
#endif // BOOST_OS_WINDOWS

#if BOOST_OS_UNIX
#include <emilua/file_descriptor.hpp>
#include <emilua/unix.hpp>
#endif // BOOST_OS_UNIX

#if EMILUA_CONFIG_ENABLE_PLUGINS
#include <emilua/plugin.hpp>
#include <boost/preprocessor/stringize.hpp>
#include <boost/dll.hpp>
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

#if EMILUA_CONFIG_ENABLE_HTTP
#include <emilua/http.hpp>
#include <emilua/websocket.hpp>
#endif // EMILUA_CONFIG_ENABLE_HTTP

#if EMILUA_CONFIG_ENABLE_FILE_IO
#include <emilua/file.hpp>
#endif // EMILUA_CONFIG_ENABLE_FILE_IO

namespace emilua {

using namespace std::string_view_literals;
namespace fs = std::filesystem;

#if EMILUA_CONFIG_ENABLE_PLUGINS
namespace dll = boost::dll;
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

extern unsigned char start_fn_bytecode[];
extern std::size_t start_fn_bytecode_size;
extern unsigned char module_start_fn_bytecode[];
extern std::size_t module_start_fn_bytecode_size;
extern unsigned char require_bytecode[];
extern std::size_t require_bytecode_size;

static char default_modules_key;
static char module_start_fn_key;
static char loaded_modules_key;
static char ffi_module_key;

#if BOOST_OS_WINDOWS
static int lua_print(lua_State* L)
{
    thread_local std::string buf;

    int nargs = lua_gettop(L);
    buf.clear();

    lua_getglobal(L, "tostring");
    for (int i = 1 ; i <= nargs ; ++i) {
        lua_pushvalue(L, -1);
        lua_pushvalue(L, i);
        lua_call(L, 1, 1);
        if (lua_type(L, -1) != LUA_TSTRING)
            return luaL_error(L, "`tostring` must return a string to `print`");
        if (i > 1) buf += '\t';
        buf += tostringview(L);
        lua_pop(L, 1);
    }

    nowide::cout << buf << std::endl;
    return 0;
}
#endif // BOOST_OS_WINDOWS

// Throws:
//
// * std::ios_base::failure
// * std::exception
static std::string& load_module_source(
    app_context& appctx, const fs::path& module_path)
{
    [[maybe_unused]] std::lock_guard guard{appctx.modules_cache_registry_mtx};
    auto it = appctx.modules_cache_registry.find(module_path);
    if (it == appctx.modules_cache_registry.end()) {
        std::string contents;
        nowide::ifstream in{module_path, std::ios::in | std::ios::binary};
        in.exceptions(std::ios_base::badbit | std::ios_base::failbit |
                      std::ios_base::eofbit);
        {
            char buf[1];
            in.read(buf, 1);
        }
        in.seekg(0, std::ios::end);
        contents.resize(in.tellg());
        in.seekg(0, std::ios::beg);
        in.read(&contents[0], contents.size());
        in.close();

        // TODO: store bytecode instead source
        it = appctx.modules_cache_registry
            .emplace(module_path, std::move(contents))
            .first;
    }
    return it->second;
}

#if EMILUA_CONFIG_ENABLE_PLUGINS
// Throws:
//
// * std::ios_base::failure
// * std::filesystem::filesystem_error
// * std::system_error
// * std::exception
static boost::shared_ptr<plugin> load_native_module(
    std::lock_guard<std::mutex>& modules_cache_registry_guard,
    emilua::app_context& appctx, const fs::path& pluginsdir,
    std::string_view module_id)
{
    auto& cache_registry = appctx.native_modules_cache_registry;
    auto it = cache_registry.find(std::string{module_id});
    if (it != cache_registry.end())
        return it->second;

    bool already_loading = !appctx.visited_native_modules.emplace(module_id)
        .second;
    if (already_loading)
        throw std::system_error{errc::cyclic_import};

    auto deps_path = pluginsdir / (std::string{module_id} + ".deps");
    if (fs::exists(deps_path)) {
        nowide::ifstream in{deps_path, std::ios::in | std::ios::binary};
        in.exceptions(std::ios_base::badbit);
        if (in.fail())
            throw std::system_error{std::io_errc::stream};

        for (std::string line ; std::getline(in, line, '\n') ;) {
            load_native_module(modules_cache_registry_guard, appctx, pluginsdir,
                               line);
        }
        if (!in.eof())
            throw std::system_error{std::io_errc::stream};
    }

    auto native_module = dll::import_symbol<plugin>(
        pluginsdir / module_id, BOOST_PP_STRINGIZE(EMILUA_PLUGIN_SYMBOL),
        dll::load_mode::append_decorations);
    cache_registry.emplace(
        std::piecewise_construct, std::forward_as_tuple(module_id),
        std::forward_as_tuple(native_module));
    native_module->init_appctx(appctx);
    return native_module;
}
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

static int mark_module_as_loaded(lua_State* L)
{
    rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);

    // This function is never called from a user-created coroutine, so we can
    // avoid the usual get_vm_context(L).current_fiber() ping-pong boilerplate.
    rawgetp(L, LUA_REGISTRYINDEX, &fiber_list_key);
    lua_pushthread(L);
    lua_rawget(L, -2);
    lua_rawgeti(L, -1, FiberDataIndex::STACK);
    lua_rawgeti(L, -1, (int)lua_objlen(L, -1));

    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_rawset(L, -6);

    lua_pushvalue(L, LUA_GLOBALSINDEX);
    return 1;
}

static int require(lua_State* L)
{
    // std::string_view::starts_with() only appeared in C++20
    static constexpr auto starts_with = [](
        std::string_view base, std::string_view prefix) {
        base = base.substr(0, prefix.size());
        return base == prefix;
    };

    auto vm_ctx = get_vm_context(L).shared_from_this();
    luaL_checktype(L, 1, LUA_TSTRING);
    auto module_id = tostringview(L, 1);

    rawgetp(L, LUA_REGISTRYINDEX, &fiber_list_key);
    lua_pushthread(vm_ctx->current_fiber());
    lua_xmove(vm_ctx->current_fiber(), L, 1);
    lua_rawget(L, -2);
    lua_rawgeti(L, -1, FiberDataIndex::STACK);
    lua_rawgeti(L, -2, FiberDataIndex::LEAF);
    lua_rawgeti(L, -3, FiberDataIndex::CONTEXT);
    enum { STACKIDX = -3, LEAFIDX = -2, CTXIDX = -1 };
    if (lua_type(L, STACKIDX) == LUA_TNIL) {
        push(L, errc::only_main_fiber_may_import);
        return lua_error(L);
    }
    bool is_leaf = lua_toboolean(L, LEAFIDX);
    lua_Integer lua_context;
    switch (lua_tointeger(L, CTXIDX)) {
    case ContextType::test:
        lua_context = starts_with(module_id, ".") ?
            ContextType::test : ContextType::regular_context;
        break;
    default:
        lua_context = ContextType::regular_context;
    }

    auto start_module_fiber = [L,&vm_ctx,lua_context](
        const fs::path module_path,
        const std::string& module_source,
        bool module_is_leaf,
#if __has_include(<experimental/memory>)
        std::experimental::observer_ptr<bool> commit_package_as_loaded
#else
        bool* commit_package_as_loaded
#endif // __has_include(<experimental/memory>)
    ) {
        lua_State* module_fiber = lua_newthread(L);

        rawgetp(L, LUA_REGISTRYINDEX, &module_start_fn_key);
        lua_pushcfunction(L, root_scope);
        lua_pushcfunction(L, terminate_vm_with_cleanup_error);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_pcall_key);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
        lua_pushcfunction(L, mark_module_as_loaded);

        std::string name{'@'};
        name += module_path.u8string();
        switch (int res = luaL_loadbuffer(
            L, module_source.data(), module_source.size(), name.data()
        ) ; res) {
        case 0:
            break;
        case LUA_ERRMEM:
            push(L, std::errc::not_enough_memory);
            [[fallthrough]];
        default:
            return lua_error(L);
        }

        lua_pushvalue(L, -1);
        lua_xmove(L, module_fiber, 1);

        // pushes module fiber's start-fn onto the stack
        lua_call(L, 6, 1);

        lua_xmove(L, module_fiber, 1);

        // default_modules_key {{{
        lua_newtable(L);

        rawgetp(L, LUA_REGISTRYINDEX, &default_modules_key);
        lua_pushnil(L);
        while (lua_next(L, -2) != 0) {
            lua_pushvalue(L, -2);
            lua_insert(L, -2);
            lua_rawset(L, -5);
        }
        lua_pop(L, 1);

        lua_pushliteral(L, "_G");
        lua_pushvalue(L, -2);
        lua_rawset(L, -3);

        std::string_view ctx_str;
        switch (lua_context) {
        case ContextType::regular_context:
            ctx_str = "";
            break;
        case ContextType::error_category:
            assert(false);
            break;
        case ContextType::main:
            ctx_str = "main";
            break;
        case ContextType::test:
            ctx_str = "test";
            break;
        case ContextType::worker:
            ctx_str = "worker";
            break;
        }
        lua_pushliteral(L, "_CONTEXT");
        push(L, ctx_str);
        lua_rawset(L, -3);

        lua_xmove(L, module_fiber, 1);
        lua_pushvalue(module_fiber, -1);
        lua_replace(module_fiber, LUA_GLOBALSINDEX);
        lua_setfenv(module_fiber, -3);
        lua_remove(module_fiber, -2);
        // }}} default_modules_key

        init_new_coro_or_fiber_scope(module_fiber, L);

        // FiberDataIndex {{{
        rawgetp(L, LUA_REGISTRYINDEX, &fiber_list_key);
        lua_insert(L, -2);
        lua_createtable(
            L,
            /*narr=*/EMILUA_IMPL_INITIAL_MODULE_FIBER_DATA_CAPACITY,
            /*nrec=*/0);

        if (commit_package_as_loaded) {
            lua_createtable(L, /*narr=*/1, /*nrec=*/0);
            push(L, module_path);
            lua_pushvalue(L, -1);
            // redundant to STACK, but simplifies code branches elsewhere
            lua_rawseti(L, -4, FiberDataIndex::SOURCE_PATH);
            lua_rawseti(L, -2, 1);
            lua_rawseti(L, -2, FiberDataIndex::STACK);
        } else {
            int parent_stacksize = lua_objlen(L, STACKIDX - 3);
            lua_createtable(L, /*narr=*/parent_stacksize + 1, /*nrec=*/0);
            for (int i = 1 ; i <= parent_stacksize ; ++i) {
                lua_rawgeti(L, STACKIDX - 4, i);
                lua_rawseti(L, -2, i);
            }
            push(L, module_path);
            lua_pushvalue(L, -1);
            // redundant to STACK, but simplifies code branches elsewhere
            lua_rawseti(L, -4, FiberDataIndex::SOURCE_PATH);
            lua_rawseti(L, -2, parent_stacksize + 1);
            lua_rawseti(L, -2, FiberDataIndex::STACK);
        }

        lua_pushboolean(L, module_is_leaf ? 1 : 0);
        lua_rawseti(L, -2, FiberDataIndex::LEAF);

        lua_pushinteger(L, lua_context);
        lua_rawseti(L, -2, FiberDataIndex::CONTEXT);

        // when boolean (i.e. not integer), lua code requests to change this
        // setting are ignored
        lua_pushboolean(L, 1);
        lua_rawseti(L, -2, FiberDataIndex::INTERRUPTION_DISABLED);

        lua_pushthread(vm_ctx->current_fiber());
        lua_xmove(vm_ctx->current_fiber(), L, 1);
        lua_rawseti(L, -2, FiberDataIndex::JOINER);

        lua_pushthread(vm_ctx->current_fiber());
        lua_xmove(vm_ctx->current_fiber(), L, 1);
        lua_rawget(L, -4);
        lua_rawgeti(L, -1, FiberDataIndex::LOCAL_STORAGE);
        lua_rawseti(L, -3, FiberDataIndex::LOCAL_STORAGE);
        lua_pop(L, 1);

        // From now on to the rest of this function, every raised exception
        // must kill the whole VM or else we risk leaking a handle
        lua_rawset(L, -3);
        // }}} FiberDataIndex

        if (commit_package_as_loaded)
            *commit_package_as_loaded = true;

        vm_ctx->strand().defer([vm_ctx,module_fiber]() {
            vm_ctx->fiber_resume(
                module_fiber,
                hana::make_set(vm_context::options::skip_clear_interrupter));
        }, std::allocator<void>{});

        return lua_yield(L, 0);
    };

    /*!re2c
    re2c:define:YYCTYPE = char;
    re2c:yyfill:enable = 0;
    re2c:indent:string = "    ";
    */
    /*!include:re2c "emilua/modules.re" */
    if (starts_with(module_id, ".")) {
        if (starts_with(module_id, "./"))
            module_id.remove_prefix(2);

        const char* YYCURSOR = module_id.data();
        const char* YYMARKER;
        const char* begin;
        int nparents = 0;
    loop_parse_dot:
        begin = YYCURSOR;
        %{
        * {
            push(L, errc::invalid_module_name, "module", tostringview(L, 1));
            return lua_error(L);
        }
        {emilua_parentpat} {
            ++nparents;
            goto loop_parse_dot;
        }
        {emilua_modnamepat} {
            if (*YYCURSOR != '\0') {
                push(L, errc::invalid_module_name,
                     "module", tostringview(L, 1));
                return lua_error(L);
            }
            goto end_parse_dot;
        }
        %}
    end_parse_dot:

        module_id = std::string_view(begin, YYCURSOR - begin);

        if (nparents == 0 && is_leaf) {
            push(L, errc::leaf_cannot_import_child);
            return lua_error(L);
        }

        // Our detection to this error is very limited, but this is not a
        // reason to worry.
        int parent_stacksize = lua_objlen(L, STACKIDX);
        if (nparents >= parent_stacksize) {
            push(L, errc::root_cannot_import_parent);
            return lua_error(L);
        }

        lua_rawgeti(L, STACKIDX, parent_stacksize);
        fs::path module_path{widen_on_windows(tostringview(L)),
                             fs::path::native_format};
        lua_pop(L, 1);
        module_path = module_path.parent_path();
        for (int i = (is_leaf ? 1u : 0u) ; i != nparents ; ++i) {
            module_path = module_path.parent_path();
        }

        bool module_is_leaf;
        try {
            if (fs::exists(module_path / (std::string{module_id} + ".lua"))) {
                module_path /= std::string{module_id} + ".lua";
                module_is_leaf = true;
            } else if (fs::exists(module_path / module_id / "init.lua")) {
                module_path /= module_id;
                module_path /= "init.lua";
                module_is_leaf = false;
            } else {
                throw std::system_error{errc::module_not_found};
            }
        } catch (const std::system_error& e) {
            push(L, e.code(), "module", tostringview(L, 1));
            return lua_error(L);
        }

        {
            rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
            push(L, module_path);
            lua_rawget(L, -2);
            if (!lua_isnil(L, -1)) {
                lua_pushboolean(L, 1);
                lua_insert(L, -2);
                return 2;
            }
            lua_pop(L, 2);
        }

        push(L, module_path);
        for (int i = 1, len = parent_stacksize ; i <= len ; ++i) {
            lua_rawgeti(L, STACKIDX - 1, i);
            if (lua_rawequal(L, -1, -2)) {
                push(L, errc::cyclic_import);
                return lua_error(L);
            }
            lua_pop(L, 1);
        }
        lua_pop(L, 1);

        std::optional<std::reference_wrapper<std::string>> module_source;
        try {
            module_source = load_module_source(vm_ctx->appctx, module_path);
        } catch (const std::system_error& e) {
            push(L, e.code());
            return lua_error(L);
        } catch (const std::exception& e) {
            lua_pushstring(L, e.what());
            return lua_error(L);
        }
        assert(module_source);
        return start_module_fiber(
            module_path,
            module_source->get(),
            module_is_leaf,
            nullptr);
    } else if (starts_with(module_id, "/")) {
        // TODO: detect cycles

        lua_rawgeti(L, STACKIDX, 1);
        fs::path module_path{widen_on_windows(tostringview(L)),
                             fs::path::native_format};
        lua_pop(L, 1);
        module_path = module_path.parent_path();

        const char* YYCURSOR = module_id.data();
        const char* YYMARKER;
        boost::ignore_unused(YYMARKER);
        const char* begin;
    loop_parse_slash:
        begin = YYCURSOR;
        %{
        * {
            push(L, errc::invalid_module_name, "module", tostringview(L, 1));
            return lua_error(L);
        }
        {emilua_modseppat}{emilua_modnamepat} {
            std::string_view component(begin + 1, YYCURSOR - begin - 1);
            if (*YYCURSOR == '\0') {
                module_id = component;
                goto end_parse_slash;
            } else {
                module_path /= component;
                goto loop_parse_slash;
            }
        }
        %}
    end_parse_slash:

        bool module_is_leaf;
        try {
            if (fs::exists(module_path / (std::string{module_id} + ".lua"))) {
                module_path /= std::string{module_id} + ".lua";
                module_is_leaf = true;
            } else if (fs::exists(module_path / module_id / "init.lua")) {
                module_path /= module_id;
                module_path /= "init.lua";
                module_is_leaf = false;
            } else {
                throw std::system_error{errc::module_not_found};
            }
        } catch (const std::system_error& e) {
            push(L, e.code(), "module", tostringview(L, 1));
            return lua_error(L);
        }

        {
            rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
            push(L, module_path);
            lua_rawget(L, -2);
            if (!lua_isnil(L, -1)) {
                lua_pushboolean(L, 1);
                lua_insert(L, -2);
                return 2;
            }
            lua_pop(L, 2);
        }

        std::optional<std::reference_wrapper<std::string>> module_source;
        try {
            module_source = load_module_source(vm_ctx->appctx, module_path);
        } catch (const std::system_error& e) {
            push(L, e.code());
            return lua_error(L);
        } catch (const std::exception& e) {
            lua_pushstring(L, e.what());
            return lua_error(L);
        }
        assert(module_source);
        bool commit_package_as_loaded; //< so we have a 1-sized require()-stack
        return start_module_fiber(
            module_path,
            module_source->get(),
            module_is_leaf,
#if __has_include(<experimental/memory>)
            std::experimental::make_observer(&commit_package_as_loaded)
#else
            &commit_package_as_loaded
#endif // __has_include(<experimental/memory>)
        );
    } else {
        const char* YYCURSOR = module_id.data();
        const char* YYMARKER;
        boost::ignore_unused(YYMARKER);
        %{
        * {
            push(L, errc::invalid_module_name, "module", module_id);
            return lua_error(L);
        }
        {emilua_modnamepat} {
            if (*YYCURSOR != '\0') {
                push(L, errc::invalid_module_name, "module", module_id);
                return lua_error(L);
            }
            goto end_parse_external;
        }
        %}
    end_parse_external:

        auto on_external_package = [&vm_ctx,&start_module_fiber](
            std::string_view module_id, lua_State* L
        ) -> int {
#if EMILUA_CONFIG_ENABLE_PLUGINS
            {
                rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
                // relative path (module_id), so it will only resolve native
                // modules for now
                push(L, module_id);
                lua_rawget(L, -2);
                if (!lua_isnil(L, -1)) {
                    lua_pushboolean(L, 1);
                    lua_insert(L, -2);
                    return 2;
                }
                lua_pop(L, 2);
            }
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

            for (const auto& p: vm_ctx->appctx.emilua_path) {
                bool already_loaded = !vm_ctx->visited_external_packages
                    .emplace(module_id).second;
                bool commit_package_as_loaded = false;
                BOOST_SCOPE_EXIT_ALL(&) {
                    if (!already_loaded && !commit_package_as_loaded) {
                        vm_ctx->visited_external_packages.erase(
                            vm_ctx->visited_external_packages.find(module_id));
                    }
                };

                fs::path module_path;
                bool module_is_leaf;
#if EMILUA_CONFIG_ENABLE_PLUGINS
                boost::shared_ptr<plugin> native_module;
#endif // EMILUA_CONFIG_ENABLE_PLUGINS
                try {
                    if (
                        module_path = p / (std::string{module_id} + ".lua") ;
                        fs::exists(module_path)
                    ) {
                        module_path = fs::absolute(std::move(module_path));
                        module_is_leaf = true;
                    } else if (
                        module_path = p / module_id / "init.lua" ;
                        fs::exists(module_path)
                    ) {
                        module_path = fs::absolute(std::move(module_path));
                        module_is_leaf = false;
                    } else {
#if EMILUA_CONFIG_ENABLE_PLUGINS
                        [[maybe_unused]] std::lock_guard guard{
                            vm_ctx->appctx.modules_cache_registry_mtx};
                        native_module = load_native_module(
                            guard, vm_ctx->appctx, p, module_id);
#else // EMILUA_CONFIG_ENABLE_PLUGINS
                        throw std::system_error{errc::module_not_found};
#endif // EMILUA_CONFIG_ENABLE_PLUGINS
                    }
                } catch (const std::exception&) {
                    continue;
                }

#if EMILUA_CONFIG_ENABLE_PLUGINS
                if (native_module) {
                    assert(!already_loaded);
                    auto ec = native_module->init_ioctx_services(
                        vm_ctx->strand().context());
                    if (ec) {
                        push(L, ec, "module", module_id);
                        return lua_error(L);
                    }
                    ec = native_module->init_lua_module(*vm_ctx, L);
                    if (ec) {
                        push(L, ec, "module", module_id);
                        return lua_error(L);
                    }

                    rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
                    push(L, module_id);
                    lua_pushvalue(L, -3);
                    lua_rawset(L, -3);
                    lua_pop(L, 1);

                    lua_pushboolean(L, 1);
                    lua_insert(L, -2);
                    return 2;
                }
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

                {
                    rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
                    push(L, module_path);
                    lua_rawget(L, -2);
                    if (!lua_isnil(L, -1)) {
                        assert(already_loaded);
                        lua_pushboolean(L, 1);
                        lua_insert(L, -2);
                        return 2;
                    }
                    lua_pop(L, 2);
                }

                if (already_loaded) {
                    push(L, errc::cyclic_import, "module", module_id);
                    return lua_error(L);
                }

                std::optional<std::reference_wrapper<std::string>>
                    module_source;
                try {
                    module_source = load_module_source(
                        vm_ctx->appctx, module_path);
                } catch (const std::system_error& e) {
                    push(L, e.code(), "module", module_id);
                    return lua_error(L);
                } catch (const std::exception& e) {
                    lua_pushstring(L, e.what());
                    return lua_error(L);
                }
                assert(module_source);
                return start_module_fiber(
                    module_path,
                    module_source->get(),
                    module_is_leaf,
#if __has_include(<experimental/memory>)
                    std::experimental::make_observer(&commit_package_as_loaded)
#else
                    &commit_package_as_loaded
#endif // __has_include(<experimental/memory>)
                );
            }

            push(L, errc::module_not_found, "module", module_id);
            return lua_error(L);
        };

        return dispatch_table::dispatch(
            hana::make_tuple(
                hana::make_pair(
                    BOOST_HANA_STRING(LUA_FFILIBNAME),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);

                        rawgetp(L, LUA_REGISTRYINDEX, &ffi_module_key);
                        if (lua_type(L, -1) == LUA_TNIL) {
                            lua_pop(L, 1);
                            lua_pushcfunction(L, luaopen_ffi);
                            lua_call(L, 0, 1);
                            lua_pushlightuserdata(L, &ffi_module_key);
                            lua_pushvalue(L, -2);
                            lua_rawset(L, LUA_REGISTRYINDEX);
                        }

                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("sleep_for"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &sleep_for_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("mutex"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &mutex_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("cond"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &cond_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("inbox"),
                    [&vm_ctx](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &inbox_key);
                        vm_ctx->inbox.imported = true;
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("json"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &json_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("steady_timer"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &timer_key);
                        return 2;
                    }
                ),
#if EMILUA_CONFIG_ENABLE_HTTP
                hana::make_pair(
                    BOOST_HANA_STRING("http"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &http_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("websocket"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &websocket_key);
                        return 2;
                    }
                ),
#endif // EMILUA_CONFIG_ENABLE_HTTP
                hana::make_pair(
                    BOOST_HANA_STRING("ip"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &ip_key);
                        return 2;
                    }
                ),
#if EMILUA_CONFIG_ENABLE_FILE_IO
                hana::make_pair(
                    BOOST_HANA_STRING("file"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &file_key);
                        return 2;
                    }
                ),
#endif // EMILUA_CONFIG_ENABLE_FILE_IO
#if BOOST_OS_UNIX
                hana::make_pair(
                    BOOST_HANA_STRING("unix"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &unix_key);
                        return 2;
                    }
                ),
#endif // BOOST_OS_UNIX
                hana::make_pair(
                    BOOST_HANA_STRING("stream"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &stream_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("regex"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &regex_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("serial_port"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &serial_port_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("tls"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &tls_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("system"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &system_key);
                        return 2;
                    }
                )
            ),
            on_external_package,
            module_id,
            L
        );
    }
}

std::shared_ptr<vm_context> make_vm(asio::io_context& ioctx,
                                    emilua::app_context& appctx,
                                    fs::path entry_point,
                                    ContextType lua_context)
{
    switch (lua_context) {
    case ContextType::regular_context:
    case ContextType::error_category:
        throw exception{errc::bad_root_context};
    case ContextType::main:
    case ContextType::test:
    case ContextType::worker:
        break;
    }

    if (!entry_point.is_absolute())
        entry_point = fs::absolute(std::move(entry_point));

    // Given we do `foo.parent_path() / (module_id + .lua)` to find the module
    // file the path separator might change the target string and hinder our
    // ECYCLE detection. Normalizing the path before it even enters the module
    // stack fixes the issue.
    entry_point.make_preferred();

#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 1 || \
    EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 0
    strand_type strand{ioctx.get_executor()};
#else
    strand_type strand{ioctx};
#endif
    auto state = std::make_shared<vm_context>(appctx, strand);
    assert(state->valid());

    lua_State* L = state->L();
    lua_gc(L, LUA_GCSTOP, 0);
    BOOST_SCOPE_EXIT_ALL(L) {
        lua_gc(L, LUA_GCRESTART, 0);
    };

    {
        lua_pushlightuserdata(L, &detail::context_key);
        lua_pushlightuserdata(L, state.get());
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &yield_reason_is_native_key);
        lua_pushboolean(L, 1);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &detail::error_category_mt_key);
        lua_createtable(L, /*narr=*/0, /*nrec=*/4);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "error_category");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__eq");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                auto cat1 = reinterpret_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat1);
                auto cat2 = reinterpret_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat2);
                return *cat1 == *cat2;
            }
        );
        lua_rawset(L, -3);

        lua_pushliteral(L, "__tostring");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                auto cat = reinterpret_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat);
                lua_pushstring(L, (*cat)->name());
                return 1;
            }
        );
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                auto cat = reinterpret_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat);
                auto key = tostringview(L, 2);
                if (key == "message") {
                    lua_pushlightuserdata(L, *cat);
                    lua_pushcclosure(
                        L,
                        [](lua_State* L) -> int {
                            luaL_checktype(L, 1, LUA_TNUMBER);
                            auto cat = reinterpret_cast<std::error_category*>(
                                lua_touserdata(L, lua_upvalueindex(1)));
                            push(L, cat->message(lua_tonumber(L, 1)));
                            return 1;
                        },
                        1
                    );
                    return 1;
                } else {
                    push(L, errc::bad_index, "index", 2);
                    return lua_error(L);
                }
            }
        );
        lua_rawset(L, -3);

        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &detail::error_code_mt_key);
        lua_createtable(L, /*narr=*/0, /*nrec=*/2);

        lua_pushliteral(L, "__eq");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                luaL_checktype(L, 1, LUA_TTABLE);
                luaL_checktype(L, 2, LUA_TTABLE);
                lua_pushliteral(L, "code");
                lua_pushvalue(L, -1);
                lua_rawget(L, 1);
                lua_pushvalue(L, -2);
                lua_rawget(L, 2);
                if (!lua_rawequal(L, -1, -2)) {
                    lua_pushboolean(L, 0);
                    return 1;
                }
                lua_pushliteral(L, "category");
                lua_pushvalue(L, -1);
                lua_rawget(L, 1);
                lua_pushvalue(L, -2);
                lua_rawget(L, 2);
                lua_pushboolean(L, lua_equal(L, -1, -2));
                return 1;
            }
        );
        lua_rawset(L, -3);

        lua_pushliteral(L, "__tostring");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                luaL_checktype(L, 1, LUA_TTABLE);
                lua_pushliteral(L, "code");
                lua_rawget(L, 1);
                if (lua_type(L, -1) != LUA_TNUMBER) {
                    push(L, std::errc::invalid_argument);
                    return lua_error(L);
                }
                int val = lua_tonumber(L, -1);
                lua_pushliteral(L, "category");
                lua_rawget(L, 1);
                if (!lua_getmetatable(L, -1)) {
                    push(L, std::errc::invalid_argument);
                    return lua_error(L);
                }
                rawgetp(L, LUA_REGISTRYINDEX, &detail::error_category_mt_key);
                if (!lua_rawequal(L, -1, -2)) {
                    push(L, std::errc::invalid_argument);
                    return lua_error(L);
                }
                auto cat = reinterpret_cast<std::error_category**>(
                    lua_touserdata(L, -3));
                assert(cat);
                push(L, (*cat)->message(val));
                return 1;
            }
        );
        lua_rawset(L, -3);

        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &loaded_modules_key);
        lua_createtable(L, /*narr=*/0, /*nrec=*/0);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_createtable(L, /*narr=*/0, /*nrec=*/0);

        lua_pushlightuserdata(L, &fiber_list_key);
        lua_pushvalue(L, -2);
        lua_rawset(L, LUA_REGISTRYINDEX);

        lua_pushthread(L);
        lua_createtable(
            L,
            /*narr=*/EMILUA_IMPL_INITIAL_MODULE_FIBER_DATA_CAPACITY,
            /*nrec=*/0);

        lua_createtable(L, /*narr=*/1, /*nrec=*/0);
        push(L, entry_point);
        lua_pushvalue(L, -1);
        lua_rawseti(L, -4, FiberDataIndex::SOURCE_PATH);
        lua_rawseti(L, -2, 1);
        lua_rawseti(L, -2, FiberDataIndex::STACK);

        lua_pushboolean(L, 0);
        lua_rawseti(L, -2, FiberDataIndex::LEAF);

        lua_pushinteger(L, lua_context);
        lua_rawseti(L, -2, FiberDataIndex::CONTEXT);

        // when boolean (i.e. not integer), lua code requests to change this
        // setting are ignored
        lua_pushboolean(L, 1);
        lua_rawseti(L, -2, FiberDataIndex::INTERRUPTION_DISABLED);

        lua_pushboolean(L, 0);
        lua_rawseti(L, -2, FiberDataIndex::JOINER);

        lua_newtable(L);
        lua_rawseti(L, -2, FiberDataIndex::LOCAL_STORAGE);

        lua_rawset(L, -3);
        lua_pop(L, 1);
    }

    lua_pushcfunction(L, luaopen_base);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_string);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_table);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_math);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_bit);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_jit);
    lua_call(L, 0, 0);

    lua_pushlightuserdata(L, &raw_unpack_key);
    lua_pushliteral(L, "unpack");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_xpcall_key);
    lua_pushliteral(L, "xpcall");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_pcall_key);
    lua_pushliteral(L, "pcall");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_error_key);
    lua_pushliteral(L, "error");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_type_key);
    lua_pushliteral(L, "type");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_pairs_key);
    lua_pushliteral(L, "pairs");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_ipairs_key);
    lua_pushliteral(L, "ipairs");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_next_key);
    lua_pushliteral(L, "next");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_setmetatable_key);
    lua_pushliteral(L, "setmetatable");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_getmetatable_key);
    lua_pushliteral(L, "getmetatable");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    {
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(require_bytecode),
            require_bytecode_size, nullptr);
        assert(res == 0); boost::ignore_unused(res);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
        lua_pushcfunction(L, require);
        lua_call(L, 2, 1);
    }
    lua_setglobal(L, "require");

#if BOOST_OS_WINDOWS
    lua_pushcfunction(L, emilua::lua_print);
    lua_setglobal(L, "print");
#endif

    // core modules (don't change order here) {{{
    init_scope_cleanup_module(L);
    init_lua_shim_module(L);
    init_fiber_module(L);
    init_mutex_module(L);
    init_cond_module(L);
    init_actor_module(L);
    init_async_base(L);

#if BOOST_OS_UNIX
    init_file_descriptor(L);
#endif // BOOST_OS_UNIX
    // }}}

    // extra modules {{{
    init_timer(L);
    init_json_module(L);
    init_ip(L);
    init_tls(L);
    init_system(L);
    init_byte_span(L);
    init_serial_port(L);
    init_regex(L);
    init_stream(L); //< scanner depends on regex mt

#if BOOST_OS_UNIX
    init_unix(L);
#endif // BOOST_OS_UNIX

#if EMILUA_CONFIG_ENABLE_HTTP
    init_http(L);
    init_websocket(L);
#endif // EMILUA_CONFIG_ENABLE_HTTP

#if EMILUA_CONFIG_ENABLE_FILE_IO
    init_file(L);
#endif // EMILUA_CONFIG_ENABLE_FILE_IO
    // }}}

    rawgetp(L, LUA_REGISTRYINDEX, &byte_span_key);
    lua_setglobal(L, "byte_span");

    // default_modules_key {{{
    lua_pushliteral(L, "_G");
    lua_pushnil(L);
    lua_rawset(L, LUA_GLOBALSINDEX);

    lua_pushlightuserdata(L, &default_modules_key);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_newtable(L);
    lua_replace(L, LUA_GLOBALSINDEX);

    rawgetp(L, LUA_REGISTRYINDEX, &default_modules_key);
    lua_pushnil(L);
    while (lua_next(L, -2) != 0) {
        lua_pushvalue(L, -2);
        lua_insert(L, -2);
        lua_rawset(L, LUA_GLOBALSINDEX);
    }
    lua_pop(L, 1);

    lua_pushliteral(L, "_G");
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_GLOBALSINDEX);
    // }}}

    {
        std::string_view ctx_str;
        switch (lua_context) {
        case ContextType::regular_context:
        case ContextType::error_category:
            assert(false);
            break;
        case ContextType::main:
            ctx_str = "main";
            break;
        case ContextType::test:
            ctx_str = "test";
            break;
        case ContextType::worker:
            ctx_str = "worker";
            break;
        }
        push(L, ctx_str);
        lua_setglobal(L, "_CONTEXT");
    }

    // async_event_thread
    {
        lua_State* async_event_thread = lua_newthread(L);
        init_new_coro_or_fiber_scope(async_event_thread, L);

        rawgetp(async_event_thread, LUA_REGISTRYINDEX, &fiber_list_key);
        lua_pushthread(async_event_thread);
        lua_createtable(
            async_event_thread,
            /*narr=*/EMILUA_IMPL_INITIAL_FIBER_DATA_CAPACITY,
            /*nrec=*/0);
        {
            lua_pushboolean(async_event_thread, 1);
            lua_rawseti(async_event_thread, -2,
                        FiberDataIndex::INTERRUPTION_DISABLED);

            lua_pushinteger(async_event_thread, 1);
            lua_rawseti(async_event_thread, -2,
                        FiberDataIndex::SUSPENSION_DISALLOWED);

            lua_pushboolean(async_event_thread, 0);
            lua_rawseti(async_event_thread, -2, FiberDataIndex::JOINER);

            push(async_event_thread, entry_point);
            lua_rawseti(async_event_thread, -2, FiberDataIndex::SOURCE_PATH);
        }
        lua_rawset(async_event_thread, -3);
        state->async_event_thread(async_event_thread);
        lua_pop(async_event_thread, 1);
        lua_pop(L, 1);
    }

    std::string& module_source = load_module_source(state->appctx, entry_point);

    {
        lua_pushlightuserdata(L, &module_start_fn_key);
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(module_start_fn_bytecode),
            module_start_fn_bytecode_size, nullptr);
        assert(res == 0); boost::ignore_unused(res);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(start_fn_bytecode),
            start_fn_bytecode_size, nullptr);
        assert(res == 0); boost::ignore_unused(res);
        lua_pushcfunction(L, root_scope);
        lua_pushcfunction(L, set_current_traceback);
        lua_pushcfunction(L, terminate_vm_with_cleanup_error);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_xpcall_key);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_pcall_key);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
    }

    std::string name{'@'};
    name += entry_point.u8string();
    switch (int res = luaL_loadbuffer(
        L, module_source.data(), module_source.size(), name.data()
    ) ; res) {
    case 0:
        break;
    case LUA_ERRMEM:
        throw std::bad_alloc();
    default: {
        std::size_t len;
        const char* str = lua_tolstring(L, -1, &len);
        throw lua_exception{res, std::string{str, len}};
    }
    }

    int res = lua_pcall(L, 7, 1, 0);
    if (res == LUA_ERRMEM)
        throw std::bad_alloc();
    assert(res == 0);

    return state;
}

} // namespace emilua

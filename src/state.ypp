/* Copyright (c) 2020, 2021, 2022, 2023 Vin√≠cius dos Santos Oliveira

   Distributed under the Boost Software License, Version 1.0. (See accompanying
   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) */

#include <iostream>
#include <new>

#include <boost/nowide/fstream.hpp>

#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wnullability-extension"
#endif
#include <sord/sordmm.hpp>
#if defined(__clang__)
# pragma clang diagnostic pop
#endif

#include <emilua/detail/core.hpp>
#include <emilua/condition_variable.hpp>
#include <emilua/dispatch_table.hpp>
#include <emilua/scope_cleanup.hpp>
#include <emilua/serial_port.hpp>
#include <emilua/async_base.hpp>
#include <emilua/filesystem.hpp>
#include <emilua/byte_span.hpp>
#include <emilua/lua_shim.hpp>
#include <emilua/windows.hpp>
#include <emilua/stream.hpp>
#include <emilua/system.hpp>
#include <emilua/fiber.hpp>
#include <emilua/actor.hpp>
#include <emilua/mutex.hpp>
#include <emilua/regex.hpp>
#include <emilua/state.hpp>
#include <emilua/time.hpp>
#include <emilua/json.hpp>
#include <emilua/pipe.hpp>
#include <emilua/tls.hpp>
#include <emilua/ip.hpp>

#include <boost/scope_exit.hpp>

#if __has_include(<experimental/memory>)
#include <experimental/memory>
#endif // __has_include(<experimental/memory>)

#if BOOST_OS_WINDOWS
#include <boost/nowide/iostream.hpp>
#endif // BOOST_OS_WINDOWS

#if BOOST_OS_UNIX
#include <emilua/file_descriptor.hpp>
#include <emilua/unix.hpp>
#endif // BOOST_OS_UNIX

#if EMILUA_CONFIG_ENABLE_PLUGINS
#include <emilua/plugin.hpp>
#include <boost/preprocessor/stringize.hpp>
#include <boost/dll.hpp>
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

#if EMILUA_CONFIG_ENABLE_HTTP
#include <emilua/http.hpp>
#include <emilua/websocket.hpp>
#endif // EMILUA_CONFIG_ENABLE_HTTP

#if EMILUA_CONFIG_ENABLE_FILE_IO
#include <emilua/file.hpp>
#endif // EMILUA_CONFIG_ENABLE_FILE_IO

namespace emilua {

using namespace std::string_view_literals;
namespace fs = std::filesystem;

#if EMILUA_CONFIG_ENABLE_PLUGINS
namespace dll = boost::dll;
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

extern unsigned char start_fn_bytecode[];
extern std::size_t start_fn_bytecode_size;
extern unsigned char module_start_fn_bytecode[];
extern std::size_t module_start_fn_bytecode_size;
extern unsigned char require_bytecode[];
extern std::size_t require_bytecode_size;

static char default_modules_key;
static char module_start_fn_key;
static char loaded_modules_key;
static char ffi_module_key;

#if BOOST_OS_WINDOWS
static int lua_print(lua_State* L)
{
    thread_local std::string buf;

    int nargs = lua_gettop(L);
    buf.clear();

    lua_getglobal(L, "tostring");
    for (int i = 1 ; i <= nargs ; ++i) {
        lua_pushvalue(L, -1);
        lua_pushvalue(L, i);
        lua_call(L, 1, 1);
        if (lua_type(L, -1) != LUA_TSTRING)
            return luaL_error(L, "`tostring` must return a string to `print`");
        if (i > 1) buf += '\t';
        buf += tostringview(L);
        lua_pop(L, 1);
    }

    nowide::cout << buf << std::endl;
    return 0;
}
#endif // BOOST_OS_WINDOWS

// Throws:
//
// * std::ios_base::failure
// * std::exception
static std::string& load_module_source(
    app_context& appctx, const fs::path& module_path)
{
    [[maybe_unused]] std::lock_guard guard{appctx.modules_cache_registry_mtx};
    auto it = appctx.modules_cache_registry.find(module_path);
    if (it == appctx.modules_cache_registry.end()) {
        std::string contents;
        nowide::ifstream in{module_path, std::ios::in | std::ios::binary};
        in.exceptions(std::ios_base::badbit | std::ios_base::failbit |
                      std::ios_base::eofbit);
        {
            char buf[1];
            in.read(buf, 1);
        }
        in.seekg(0, std::ios::end);
        contents.resize(in.tellg());
        in.seekg(0, std::ios::beg);
        in.read(&contents[0], contents.size());
        in.close();

        // TODO: store bytecode instead source
        it = appctx.modules_cache_registry
            .emplace(module_path, std::move(contents))
            .first;
    }
    return it->second;
}

// Throws:
//
// * std::ios_base::failure
// * std::system_error
// * std::exception
static rdf_error_category& load_rdf_error_category(
    std::lock_guard<std::mutex>& /*modules_cache_registry_guard*/,
    emilua::app_context& appctx, const fs::path& module_path)
{
    auto& cache_registry = appctx.rdf_ec_cache_registry;
    auto it = cache_registry.find(module_path);
    if (it == cache_registry.end()) {
        std::string contents;
        nowide::ifstream in{module_path, std::ios::in | std::ios::binary};
        in.exceptions(std::ios_base::badbit | std::ios_base::failbit |
                      std::ios_base::eofbit);
        {
            char buf[1];
            in.read(buf, 1);
        }
        in.seekg(0, std::ios::end);
        contents.resize(in.tellg());
        in.seekg(0, std::ios::beg);
        in.read(&contents[0], contents.size());
        in.close();

        std::string base_uri{"file://"};
        {
            auto s = module_path.u8string();
            base_uri.append(reinterpret_cast<char*>(s.data()), s.size());
        }

        Sord::Namespaces prefixes;

        Sord::World world;
        Sord::Model model{world, base_uri};
        model.load_string(prefixes.c_obj(), SerdSyntax::SERD_TURTLE,
                          contents.c_str(), contents.size(), base_uri);
        if (model.num_quads() == 0) {
            throw std::system_error{errc::bad_rdf};
        }

        const Sord::Node module_node{
            world, Sord::Node::URI, "about:emilua-module"};
        const Sord::Node category_schema{
            world, Sord::Node::URI,
            "https://schema.emilua.org/error_category/0/"};
        const Sord::Node type_property{
            world, Sord::Node::URI,
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"};

        {
            Sord::Node type;
            for (
                auto it = model.find(module_node, type_property, Sord::Node{}) ;
                !it.end() ; it.next()
            ) {
                if (type.is_valid() || !it.get_object().is_uri()) {
                    throw std::system_error{errc::bad_rdf_module};
                }

                type = it.get_object();
            }
            if (!type.is_valid()) {
                throw std::system_error{errc::bad_rdf_module};
            }
            if (type != category_schema) {
                throw std::system_error{errc::bad_rdf_error_category};
            }
        }

        auto category = std::make_unique<rdf_error_category>();
        category->name_ = base_uri;

        const Sord::Node error_property{
            world, Sord::Node::URI,
            "https://schema.emilua.org/error_category/0/#error"};
        const Sord::Node code_property{
            world, Sord::Node::URI,
            "https://schema.emilua.org/error_category/0/#code"};
        const Sord::Node alias_property{
            world, Sord::Node::URI,
            "https://schema.emilua.org/error_category/0/#alias"};
        const Sord::Node message_property{
            world, Sord::Node::URI,
            "https://schema.emilua.org/error_category/0/#message"};
        const Sord::Node generic_error_property{
            world, Sord::Node::URI,
            "https://schema.emilua.org/error_category/0/#generic_error"};

        for (
            auto it2 = model.find(module_node, error_property, Sord::Node{}) ;
            !it2.end() ; it2.next()
        ) {
            auto code = model.get(
                it2.get_object(), code_property, Sord::Node{});
            if (!code.is_valid() || !code.is_int()) {
                throw std::system_error{errc::bad_rdf_error_category};
            }

            for (
                auto it3 = model.find(
                    it2.get_object(), alias_property, Sord::Node{}) ;
                !it3.end() ; it3.next()
            ) {
                auto alias = it3.get_object();
                if (
                    alias.type() != Sord::Node::LITERAL ||
                    sord_node_get_datatype(alias.c_obj()) != nullptr ||
                    !category->aliases.emplace(alias.to_string(), code.to_int())
                    .second
                ) {
                    throw std::system_error{errc::bad_rdf_error_category};
                }
            }

            for (
                auto it3 = model.find(
                    it2.get_object(), message_property, Sord::Node{}) ;
                !it3.end() ; it3.next()
            ) {
                auto message = it3.get_object();
                if (
                    message.type() != Sord::Node::LITERAL ||
                    sord_node_get_datatype(message.c_obj()) != nullptr
                ) {
                    throw std::system_error{errc::bad_rdf_error_category};
                }

                std::string locale;
                if (
                    auto lang = sord_node_get_language(message.c_obj()) ;
                    lang != nullptr
                ) {
                    locale = lang;
                    for (char& c: locale) { if (c == '-') { c = '_'; break; } }
                }

                auto& messages = category->messages[code.to_int()];
                if (!messages.emplace(locale, message.to_string()).second) {
                    throw std::system_error{errc::bad_rdf_error_category};
                }
            }

            {
                auto& messages = category->messages[code.to_int()];
                if (messages.find(std::string{}) == messages.end()) {
                    throw std::system_error{errc::bad_rdf_error_category};
                }
            }

            for (
                auto it3 = model.find(
                    it2.get_object(), generic_error_property, Sord::Node{}) ;
                !it3.end() ; it3.next()
            ) {
                auto pe = it3.get_object();
                if (
                    pe.type() != Sord::Node::LITERAL ||
                    sord_node_get_datatype(pe.c_obj()) != nullptr
                ) {
                    throw std::system_error{errc::bad_rdf_error_category};
                }

                int ge = static_cast<int>(dispatch_table::dispatch(
                    hana::make_tuple(
                        hana::make_pair(
                            BOOST_HANA_STRING("EAFNOSUPPORT"),
                            []() {
                                return std::errc::address_family_not_supported;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EADDRINUSE"),
                            []() { return std::errc::address_in_use; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EADDRNOTAVAIL"),
                            []() { return std::errc::address_not_available; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EISCONN"),
                            []() { return std::errc::already_connected; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("E2BIG"),
                            []() { return std::errc::argument_list_too_long; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EDOM"),
                            []() { return std::errc::argument_out_of_domain; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EFAULT"),
                            []() { return std::errc::bad_address; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EBADF"),
                            []() { return std::errc::bad_file_descriptor; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EBADMSG"),
                            []() { return std::errc::bad_message; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EPIPE"),
                            []() { return std::errc::broken_pipe; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ECONNABORTED"),
                            []() { return std::errc::connection_aborted; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EALREADY"),
                            []() {
                                return
                                    std::errc::connection_already_in_progress;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ECONNREFUSED"),
                            []() { return std::errc::connection_refused; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ECONNRESET"),
                            []() { return std::errc::connection_reset; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EXDEV"),
                            []() { return std::errc::cross_device_link; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EDESTADDRREQ"),
                            []() {
                                return std::errc::destination_address_required;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EBUSY"),
                            []() { return std::errc::device_or_resource_busy; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOTEMPTY"),
                            []() { return std::errc::directory_not_empty; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOEXEC"),
                            []() { return std::errc::executable_format_error; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EEXIST"),
                            []() { return std::errc::file_exists; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EFBIG"),
                            []() { return std::errc::file_too_large; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENAMETOOLONG"),
                            []() { return std::errc::filename_too_long; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOSYS"),
                            []() { return std::errc::function_not_supported; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EHOSTUNREACH"),
                            []() { return std::errc::host_unreachable; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EIDRM"),
                            []() { return std::errc::identifier_removed; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EILSEQ"),
                            []() { return std::errc::illegal_byte_sequence; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOTTY"),
                            []() {
                                return std::errc
                                    ::inappropriate_io_control_operation;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EINTR"),
                            []() { return std::errc::interrupted; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EINVAL"),
                            []() { return std::errc::invalid_argument; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ESPIPE"),
                            []() { return std::errc::invalid_seek; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EIO"),
                            []() { return std::errc::io_error; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EISDIR"),
                            []() { return std::errc::is_a_directory; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EMSGSIZE"),
                            []() { return std::errc::message_size; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENETDOWN"),
                            []() { return std::errc::network_down; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENETRESET"),
                            []() { return std::errc::network_reset; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENETUNREACH"),
                            []() { return std::errc::network_unreachable; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOBUFS"),
                            []() { return std::errc::no_buffer_space; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ECHILD"),
                            []() { return std::errc::no_child_process; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOLINK"),
                            []() { return std::errc::no_link; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOLCK"),
                            []() { return std::errc::no_lock_available; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOMSG"),
                            []() { return std::errc::no_message; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOPROTOOPT"),
                            []() { return std::errc::no_protocol_option; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOSPC"),
                            []() { return std::errc::no_space_on_device; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENXIO"),
                            []() {
                                return std::errc::no_such_device_or_address;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENODEV"),
                            []() { return std::errc::no_such_device; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOENT"),
                            []() {
                                return std::errc::no_such_file_or_directory;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ESRCH"),
                            []() { return std::errc::no_such_process; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOTDIR"),
                            []() { return std::errc::not_a_directory; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOTSOCK"),
                            []() { return std::errc::not_a_socket; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOTCONN"),
                            []() { return std::errc::not_connected; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOMEM"),
                            []() { return std::errc::not_enough_memory; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOTSUP"),
                            []() { return std::errc::not_supported; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ECANCELED"),
                            []() { return std::errc::operation_canceled; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EINPROGRESS"),
                            []() { return std::errc::operation_in_progress; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EPERM"),
                            []() { return std::errc::operation_not_permitted; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EOPNOTSUPP"),
                            []() { return std::errc::operation_not_supported; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EWOULDBLOCK"),
                            []() { return std::errc::operation_would_block; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EOWNERDEAD"),
                            []() { return std::errc::owner_dead; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EACCES"),
                            []() { return std::errc::permission_denied; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EPROTO"),
                            []() { return std::errc::protocol_error; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EPROTONOSUPPORT"),
                            []() { return std::errc::protocol_not_supported; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EROFS"),
                            []() { return std::errc::read_only_file_system; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EDEADLK"),
                            []() {
                                return std::errc::resource_deadlock_would_occur;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EAGAIN"),
                            []() {
                                return
                                    std::errc::resource_unavailable_try_again;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ERANGE"),
                            []() { return std::errc::result_out_of_range; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENOTRECOVERABLE"),
                            []() { return std::errc::state_not_recoverable; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ETXTBSY"),
                            []() { return std::errc::text_file_busy; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ETIMEDOUT"),
                            []() { return std::errc::timed_out; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ENFILE"),
                            []() {
                                return std::errc::too_many_files_open_in_system;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EMFILE"),
                            []() { return std::errc::too_many_files_open; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EMLINK"),
                            []() { return std::errc::too_many_links; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("ELOOP"),
                            []() {
                                return std::errc::too_many_symbolic_link_levels;
                            }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EOVERFLOW"),
                            []() { return std::errc::value_too_large; }
                        ),
                        hana::make_pair(
                            BOOST_HANA_STRING("EPROTOTYPE"),
                            []() { return std::errc::wrong_protocol_type; }
                        )
                    ),
                    [](std::string_view /*key*/) -> std::errc {
                        throw std::system_error{errc::bad_rdf_error_category};
                    },
                    pe.to_string()
                ));

                if (
                    !category->generic_errors.emplace(code.to_int(), ge).second
                ) {
                    throw std::system_error{errc::bad_rdf_error_category};
                }
            }
        }

        it = cache_registry.emplace(module_path, std::move(category)).first;
    }
    return *it->second;
}

#if EMILUA_CONFIG_ENABLE_PLUGINS
// Throws:
//
// * std::ios_base::failure
// * std::filesystem::filesystem_error
// * std::system_error
// * std::exception
static boost::shared_ptr<plugin> load_native_module(
    std::lock_guard<std::mutex>& modules_cache_registry_guard,
    emilua::app_context& appctx, const fs::path& pluginsdir,
    std::string_view module_id)
{
    auto& cache_registry = appctx.native_modules_cache_registry;
    auto it = cache_registry.find(std::string{module_id});
    if (it != cache_registry.end())
        return it->second;

    bool already_loading = !appctx.visited_native_modules.emplace(module_id)
        .second;
    if (already_loading)
        throw std::system_error{errc::cyclic_import};

    auto deps_path = pluginsdir / (std::string{module_id} + ".deps");
    if (fs::exists(deps_path)) {
        nowide::ifstream in{deps_path, std::ios::in | std::ios::binary};
        in.exceptions(std::ios_base::badbit);
        if (in.fail())
            throw std::system_error{std::io_errc::stream};

        for (std::string line ; std::getline(in, line, '\n') ;) {
            load_native_module(modules_cache_registry_guard, appctx, pluginsdir,
                               line);
        }
        if (!in.eof())
            throw std::system_error{std::io_errc::stream};
    }

    auto native_module = dll::import_symbol<plugin>(
        pluginsdir / module_id, BOOST_PP_STRINGIZE(EMILUA_PLUGIN_SYMBOL),
        dll::load_mode::append_decorations);
    cache_registry.emplace(
        std::piecewise_construct, std::forward_as_tuple(module_id),
        std::forward_as_tuple(native_module));
    native_module->init_appctx(appctx);
    return native_module;
}
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

static int mark_module_as_loaded(lua_State* L)
{
    rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);

    // This function is never called from a user-created coroutine, so we can
    // avoid the usual get_vm_context(L).current_fiber() ping-pong boilerplate.
    rawgetp(L, LUA_REGISTRYINDEX, &fiber_list_key);
    lua_pushthread(L);
    lua_rawget(L, -2);
    lua_rawgeti(L, -1, FiberDataIndex::STACK);
    lua_rawgeti(L, -1, (int)lua_objlen(L, -1));

    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_rawset(L, -6);

    lua_pushvalue(L, LUA_GLOBALSINDEX);
    return 1;
}

static int require(lua_State* L)
{
    auto vm_ctx = get_vm_context(L).shared_from_this();
    luaL_checktype(L, 1, LUA_TSTRING);
    auto module_id = tostringview(L, 1);

    rawgetp(L, LUA_REGISTRYINDEX, &fiber_list_key);
    lua_pushthread(vm_ctx->current_fiber());
    lua_xmove(vm_ctx->current_fiber(), L, 1);
    lua_rawget(L, -2);
    lua_rawgeti(L, -1, FiberDataIndex::STACK);
    lua_rawgeti(L, -2, FiberDataIndex::LEAF);
    lua_rawgeti(L, -3, FiberDataIndex::CONTEXT);
    enum { STACKIDX = -3, LEAFIDX = -2, CTXIDX = -1 };
    if (lua_type(L, STACKIDX) == LUA_TNIL) {
        push(L, errc::only_main_fiber_may_import);
        return lua_error(L);
    }
    bool is_leaf = lua_toboolean(L, LEAFIDX);
    lua_Integer lua_context;
    switch (lua_tointeger(L, CTXIDX)) {
    case ContextType::test:
        lua_context = module_id.starts_with(".") ?
            ContextType::test : ContextType::regular_context;
        break;
    default:
        lua_context = ContextType::regular_context;
    }

    auto start_module_fiber = [L,&vm_ctx,lua_context](
        const fs::path module_path,
        const std::string& module_source,
        bool module_is_leaf,
#if __has_include(<experimental/memory>)
        std::experimental::observer_ptr<bool> commit_package_as_loaded
#else
        bool* commit_package_as_loaded
#endif // __has_include(<experimental/memory>)
    ) {
        lua_State* module_fiber = lua_newthread(L);

        rawgetp(L, LUA_REGISTRYINDEX, &module_start_fn_key);
        lua_pushcfunction(L, root_scope);
        lua_pushcfunction(L, terminate_vm_with_cleanup_error);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_pcall_key);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
        lua_pushcfunction(L, mark_module_as_loaded);

        std::string name{'@'};
        {
            auto u8name = module_path.u8string();
            name.append(reinterpret_cast<char*>(u8name.data()), u8name.size());
        }
        switch (int res = luaL_loadbuffer(
            L, module_source.data(), module_source.size(), name.data()
        ) ; res) {
        case 0:
            break;
        case LUA_ERRMEM:
            push(L, std::errc::not_enough_memory);
            [[fallthrough]];
        default:
            return lua_error(L);
        }

        lua_pushvalue(L, -1);
        lua_xmove(L, module_fiber, 1);

        // pushes module fiber's start-fn onto the stack
        lua_call(L, 6, 1);

        lua_xmove(L, module_fiber, 1);

        // default_modules_key {{{
        lua_newtable(L);

        rawgetp(L, LUA_REGISTRYINDEX, &default_modules_key);
        lua_pushnil(L);
        while (lua_next(L, -2) != 0) {
            lua_pushvalue(L, -2);
            lua_insert(L, -2);
            lua_rawset(L, -5);
        }
        lua_pop(L, 1);

        lua_pushliteral(L, "_G");
        lua_pushvalue(L, -2);
        lua_rawset(L, -3);

        std::string_view ctx_str;
        switch (lua_context) {
        case ContextType::regular_context:
            ctx_str = "";
            break;
        case ContextType::error_category:
            assert(false);
            break;
        case ContextType::main:
            ctx_str = "main";
            break;
        case ContextType::test:
            ctx_str = "test";
            break;
        case ContextType::worker:
            ctx_str = "worker";
            break;
        }
        lua_pushliteral(L, "_CONTEXT");
        push(L, ctx_str);
        lua_rawset(L, -3);

        lua_xmove(L, module_fiber, 1);
        lua_pushvalue(module_fiber, -1);
        lua_replace(module_fiber, LUA_GLOBALSINDEX);
        lua_setfenv(module_fiber, -3);
        lua_remove(module_fiber, -2);
        // }}} default_modules_key

        init_new_coro_or_fiber_scope(module_fiber, L);

        // FiberDataIndex {{{
        rawgetp(L, LUA_REGISTRYINDEX, &fiber_list_key);
        lua_insert(L, -2);
        lua_createtable(
            L,
            /*narr=*/EMILUA_IMPL_INITIAL_MODULE_FIBER_DATA_CAPACITY,
            /*nrec=*/0);

        if (commit_package_as_loaded) {
            lua_createtable(L, /*narr=*/1, /*nrec=*/0);
            push(L, module_path);
            lua_pushvalue(L, -1);
            // redundant to STACK, but simplifies code branches elsewhere
            lua_rawseti(L, -4, FiberDataIndex::SOURCE_PATH);
            lua_rawseti(L, -2, 1);
            lua_rawseti(L, -2, FiberDataIndex::STACK);
        } else {
            int parent_stacksize = lua_objlen(L, STACKIDX - 3);
            lua_createtable(L, /*narr=*/parent_stacksize + 1, /*nrec=*/0);
            for (int i = 1 ; i <= parent_stacksize ; ++i) {
                lua_rawgeti(L, STACKIDX - 4, i);
                lua_rawseti(L, -2, i);
            }
            push(L, module_path);
            lua_pushvalue(L, -1);
            // redundant to STACK, but simplifies code branches elsewhere
            lua_rawseti(L, -4, FiberDataIndex::SOURCE_PATH);
            lua_rawseti(L, -2, parent_stacksize + 1);
            lua_rawseti(L, -2, FiberDataIndex::STACK);
        }

        lua_pushboolean(L, module_is_leaf ? 1 : 0);
        lua_rawseti(L, -2, FiberDataIndex::LEAF);

        lua_pushinteger(L, lua_context);
        lua_rawseti(L, -2, FiberDataIndex::CONTEXT);

        // when boolean (i.e. not integer), lua code requests to change this
        // setting are ignored
        lua_pushboolean(L, 1);
        lua_rawseti(L, -2, FiberDataIndex::INTERRUPTION_DISABLED);

        lua_pushthread(vm_ctx->current_fiber());
        lua_xmove(vm_ctx->current_fiber(), L, 1);
        lua_rawseti(L, -2, FiberDataIndex::JOINER);

        lua_pushthread(vm_ctx->current_fiber());
        lua_xmove(vm_ctx->current_fiber(), L, 1);
        lua_rawget(L, -4);
        lua_rawgeti(L, -1, FiberDataIndex::LOCAL_STORAGE);
        lua_rawseti(L, -3, FiberDataIndex::LOCAL_STORAGE);
        lua_pop(L, 1);

        // From now on to the rest of this function, every raised exception
        // must kill the whole VM or else we risk leaking a handle
        lua_rawset(L, -3);
        // }}} FiberDataIndex

        if (commit_package_as_loaded)
            *commit_package_as_loaded = true;

        vm_ctx->strand().defer([vm_ctx,module_fiber]() {
            vm_ctx->fiber_resume(
                module_fiber,
                hana::make_set(vm_context::options::skip_clear_interrupter));
        }, std::allocator<void>{});

        return lua_yield(L, 0);
    };

    /*!re2c
    re2c:define:YYCTYPE = char;
    re2c:yyfill:enable = 0;
    re2c:indent:string = "    ";
    */
    /*!include:re2c "emilua/modules.re" */
    if (module_id.starts_with(".")) {
        if (module_id.starts_with("./"))
            module_id.remove_prefix(2);

        const char* YYCURSOR = module_id.data();
        const char* YYMARKER;
        const char* begin;
        int nparents = 0;
    loop_parse_dot:
        begin = YYCURSOR;
        %{
        * {
            push(L, errc::invalid_module_name, "module", tostringview(L, 1));
            return lua_error(L);
        }
        {emilua_parentpat} {
            ++nparents;
            goto loop_parse_dot;
        }
        {emilua_modnamepat} {
            if (*YYCURSOR != '\0') {
                push(L, errc::invalid_module_name,
                     "module", tostringview(L, 1));
                return lua_error(L);
            }
            goto end_parse_dot;
        }
        %}
    end_parse_dot:

        module_id = std::string_view(begin, YYCURSOR - begin);

        if (nparents == 0 && is_leaf) {
            push(L, errc::leaf_cannot_import_child);
            return lua_error(L);
        }

        // Our detection to this error is very limited, but this is not a
        // reason to worry.
        int parent_stacksize = lua_objlen(L, STACKIDX);
        if (nparents >= parent_stacksize) {
            push(L, errc::root_cannot_import_parent);
            return lua_error(L);
        }

        lua_rawgeti(L, STACKIDX, parent_stacksize);
        fs::path module_path{widen_on_windows(tostringview(L)),
                             fs::path::native_format};
        lua_pop(L, 1);
        module_path = module_path.parent_path();
        for (int i = (is_leaf ? 1u : 0u) ; i != nparents ; ++i) {
            module_path = module_path.parent_path();
        }

        bool module_is_leaf;
        try {
            if (fs::exists(module_path / (std::string{module_id} + ".lua"))) {
                module_path /= std::string{module_id} + ".lua";
                module_is_leaf = true;
            } else if (fs::exists(module_path / module_id / "init.lua")) {
                module_path /= module_id;
                module_path /= "init.lua";
                module_is_leaf = false;
            } else {
                throw std::system_error{errc::module_not_found};
            }
        } catch (const std::system_error& e) {
            push(L, e.code(), "module", tostringview(L, 1));
            return lua_error(L);
        }

        {
            rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
            push(L, module_path);
            lua_rawget(L, -2);
            if (!lua_isnil(L, -1)) {
                lua_pushboolean(L, 1);
                lua_insert(L, -2);
                return 2;
            }
            lua_pop(L, 2);
        }

        push(L, module_path);
        for (int i = 1, len = parent_stacksize ; i <= len ; ++i) {
            lua_rawgeti(L, STACKIDX - 1, i);
            if (lua_rawequal(L, -1, -2)) {
                push(L, errc::cyclic_import);
                return lua_error(L);
            }
            lua_pop(L, 1);
        }
        lua_pop(L, 1);

        std::optional<std::reference_wrapper<std::string>> module_source;
        try {
            module_source = load_module_source(vm_ctx->appctx, module_path);
        } catch (const std::system_error& e) {
            push(L, e.code());
            return lua_error(L);
        } catch (const std::exception& e) {
            lua_pushstring(L, e.what());
            return lua_error(L);
        }
        assert(module_source);
        return start_module_fiber(
            module_path,
            module_source->get(),
            module_is_leaf,
            nullptr);
    } else if (module_id.starts_with("/")) {
        // TODO: detect cycles

        lua_rawgeti(L, STACKIDX, 1);
        fs::path module_path{widen_on_windows(tostringview(L)),
                             fs::path::native_format};
        lua_pop(L, 1);
        module_path = module_path.parent_path();

        const char* YYCURSOR = module_id.data();
        const char* YYMARKER;
        boost::ignore_unused(YYMARKER);
        const char* begin;
    loop_parse_slash:
        begin = YYCURSOR;
        %{
        * {
            push(L, errc::invalid_module_name, "module", tostringview(L, 1));
            return lua_error(L);
        }
        {emilua_modseppat}{emilua_modnamepat} {
            std::string_view component(begin + 1, YYCURSOR - begin - 1);
            if (*YYCURSOR == '\0') {
                module_id = component;
                goto end_parse_slash;
            } else {
                module_path /= component;
                goto loop_parse_slash;
            }
        }
        %}
    end_parse_slash:

        bool module_is_leaf;
        try {
            if (fs::exists(module_path / (std::string{module_id} + ".lua"))) {
                module_path /= std::string{module_id} + ".lua";
                module_is_leaf = true;
            } else if (fs::exists(module_path / module_id / "init.lua")) {
                module_path /= module_id;
                module_path /= "init.lua";
                module_is_leaf = false;
            } else if (
                fs::exists(module_path / (std::string{module_id} + ".ttl"))
            ) {
                module_path /= std::string{module_id} + ".ttl";

                [[maybe_unused]] std::lock_guard guard{
                    vm_ctx->appctx.modules_cache_registry_mtx};
                try {
                    const auto& error_category_module = load_rdf_error_category(
                        guard, vm_ctx->appctx,
                        fs::absolute(std::move(module_path)));

                    lua_pushboolean(L, 1);

                    *static_cast<const rdf_error_category**>(
                        lua_newuserdata(L, sizeof(void*))) =
                        &error_category_module;
                    rawgetp(L, LUA_REGISTRYINDEX,
                            &detail::rdf_error_category_module_mt_key);
                    setmetatable(L, -2);

                    return 2;
                } catch (const std::system_error& e) {
                    push(L, e.code());
                    return lua_error(L);
                } catch (const std::exception& e) {
                    lua_pushstring(L, e.what());
                    return lua_error(L);
                }
            } else {
                throw std::system_error{errc::module_not_found};
            }
        } catch (const std::system_error& e) {
            push(L, e.code(), "module", tostringview(L, 1));
            return lua_error(L);
        }

        {
            rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
            push(L, module_path);
            lua_rawget(L, -2);
            if (!lua_isnil(L, -1)) {
                lua_pushboolean(L, 1);
                lua_insert(L, -2);
                return 2;
            }
            lua_pop(L, 2);
        }

        std::optional<std::reference_wrapper<std::string>> module_source;
        try {
            module_source = load_module_source(vm_ctx->appctx, module_path);
        } catch (const std::system_error& e) {
            push(L, e.code());
            return lua_error(L);
        } catch (const std::exception& e) {
            lua_pushstring(L, e.what());
            return lua_error(L);
        }
        assert(module_source);
        bool commit_package_as_loaded; //< so we have a 1-sized require()-stack
        return start_module_fiber(
            module_path,
            module_source->get(),
            module_is_leaf,
#if __has_include(<experimental/memory>)
            std::experimental::make_observer(&commit_package_as_loaded)
#else
            &commit_package_as_loaded
#endif // __has_include(<experimental/memory>)
        );
    } else {
        const char* YYCURSOR = module_id.data();
        const char* YYMARKER;
        boost::ignore_unused(YYMARKER);
        %{
        * {
            push(L, errc::invalid_module_name, "module", module_id);
            return lua_error(L);
        }
        {emilua_modnamepat} {
            if (*YYCURSOR != '\0') {
                push(L, errc::invalid_module_name, "module", module_id);
                return lua_error(L);
            }
            goto end_parse_external;
        }
        %}
    end_parse_external:

        auto on_external_package = [&vm_ctx,&start_module_fiber](
            std::string_view module_id, lua_State* L
        ) -> int {
#if EMILUA_CONFIG_ENABLE_PLUGINS
            {
                rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
                // relative path (module_id), so it will only resolve native
                // modules for now
                push(L, module_id);
                lua_rawget(L, -2);
                if (!lua_isnil(L, -1)) {
                    lua_pushboolean(L, 1);
                    lua_insert(L, -2);
                    return 2;
                }
                lua_pop(L, 2);
            }
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

            for (const auto& p: vm_ctx->appctx.emilua_path) {
                bool already_loaded = !vm_ctx->visited_external_packages
                    .emplace(module_id).second;
                bool commit_package_as_loaded = false;
                BOOST_SCOPE_EXIT_ALL(&) {
                    if (!already_loaded && !commit_package_as_loaded) {
                        vm_ctx->visited_external_packages.erase(
                            vm_ctx->visited_external_packages.find(module_id));
                    }
                };

                fs::path module_path;
                bool module_is_leaf;
                rdf_error_category* error_category_module = nullptr;
#if EMILUA_CONFIG_ENABLE_PLUGINS
                boost::shared_ptr<plugin> native_module;
#endif // EMILUA_CONFIG_ENABLE_PLUGINS
                try {
                    if (
                        module_path = p / (std::string{module_id} + ".lua") ;
                        fs::exists(module_path)
                    ) {
                        module_path = fs::absolute(std::move(module_path));
                        module_is_leaf = true;
                    } else if (
                        module_path = p / module_id / "init.lua" ;
                        fs::exists(module_path)
                    ) {
                        module_path = fs::absolute(std::move(module_path));
                        module_is_leaf = false;
                    } else if (
                        module_path = p / (std::string{module_id} + ".ttl") ;
                        fs::exists(module_path)
                    ) {
                        [[maybe_unused]] std::lock_guard guard{
                            vm_ctx->appctx.modules_cache_registry_mtx};
                        error_category_module = &load_rdf_error_category(
                            guard, vm_ctx->appctx,
                            fs::absolute(std::move(module_path))
                        );
                    } else {
#if EMILUA_CONFIG_ENABLE_PLUGINS
                        [[maybe_unused]] std::lock_guard guard{
                            vm_ctx->appctx.modules_cache_registry_mtx};
                        native_module = load_native_module(
                            guard, vm_ctx->appctx, p, module_id);
#else // EMILUA_CONFIG_ENABLE_PLUGINS
                        throw std::system_error{errc::module_not_found};
#endif // EMILUA_CONFIG_ENABLE_PLUGINS
                    }
                } catch (const std::exception&) {
                    continue;
                }

#if EMILUA_CONFIG_ENABLE_PLUGINS
                if (native_module) {
                    assert(!already_loaded);
                    auto ec = native_module->init_ioctx_services(
                        vm_ctx->strand().context());
                    if (ec) {
                        push(L, ec, "module", module_id);
                        return lua_error(L);
                    }
                    ec = native_module->init_lua_module(*vm_ctx, L);
                    if (ec) {
                        push(L, ec, "module", module_id);
                        return lua_error(L);
                    }

                    rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
                    push(L, module_id);
                    lua_pushvalue(L, -3);
                    lua_rawset(L, -3);
                    lua_pop(L, 1);

                    lua_pushboolean(L, 1);
                    lua_insert(L, -2);
                    return 2;
                }
#endif // EMILUA_CONFIG_ENABLE_PLUGINS

                if (error_category_module) {
                    assert(!already_loaded);
                    lua_pushboolean(L, 1);

                    *static_cast<const rdf_error_category**>(
                        lua_newuserdata(L, sizeof(void*))) =
                        error_category_module;
                    rawgetp(L, LUA_REGISTRYINDEX,
                            &detail::rdf_error_category_module_mt_key);
                    setmetatable(L, -2);

                    return 2;
                }

                {
                    rawgetp(L, LUA_REGISTRYINDEX, &loaded_modules_key);
                    push(L, module_path);
                    lua_rawget(L, -2);
                    if (!lua_isnil(L, -1)) {
                        assert(already_loaded);
                        lua_pushboolean(L, 1);
                        lua_insert(L, -2);
                        return 2;
                    }
                    lua_pop(L, 2);
                }

                if (already_loaded) {
                    push(L, errc::cyclic_import, "module", module_id);
                    return lua_error(L);
                }

                std::optional<std::reference_wrapper<std::string>>
                    module_source;
                try {
                    module_source = load_module_source(
                        vm_ctx->appctx, module_path);
                } catch (const std::system_error& e) {
                    push(L, e.code(), "module", module_id);
                    return lua_error(L);
                } catch (const std::exception& e) {
                    lua_pushstring(L, e.what());
                    return lua_error(L);
                }
                assert(module_source);
                return start_module_fiber(
                    module_path,
                    module_source->get(),
                    module_is_leaf,
#if __has_include(<experimental/memory>)
                    std::experimental::make_observer(&commit_package_as_loaded)
#else
                    &commit_package_as_loaded
#endif // __has_include(<experimental/memory>)
                );
            }

            push(L, errc::module_not_found, "module", module_id);
            return lua_error(L);
        };

        return dispatch_table::dispatch(
            hana::make_tuple(
                hana::make_pair(
                    BOOST_HANA_STRING(LUA_FFILIBNAME),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);

                        rawgetp(L, LUA_REGISTRYINDEX, &ffi_module_key);
                        if (lua_type(L, -1) == LUA_TNIL) {
                            lua_pop(L, 1);
                            lua_pushcfunction(L, luaopen_ffi);
                            lua_call(L, 0, 1);
                            lua_pushlightuserdata(L, &ffi_module_key);
                            lua_pushvalue(L, -2);
                            lua_rawset(L, LUA_REGISTRYINDEX);
                        }

                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("mutex"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &mutex_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("condition_variable"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &condition_variable_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("inbox"),
                    [&vm_ctx](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &inbox_key);
                        vm_ctx->inbox.imported = true;
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("json"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &json_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("time"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &time_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("filesystem"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &filesystem_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("pipe"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &pipe_key);
                        return 2;
                    }
                ),
#if EMILUA_CONFIG_ENABLE_HTTP
                hana::make_pair(
                    BOOST_HANA_STRING("http"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &http_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("websocket"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &websocket_key);
                        return 2;
                    }
                ),
#endif // EMILUA_CONFIG_ENABLE_HTTP
                hana::make_pair(
                    BOOST_HANA_STRING("ip"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &ip_key);
                        return 2;
                    }
                ),
#if EMILUA_CONFIG_ENABLE_FILE_IO
                hana::make_pair(
                    BOOST_HANA_STRING("file"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &file_key);
                        return 2;
                    }
                ),
#endif // EMILUA_CONFIG_ENABLE_FILE_IO
#if BOOST_OS_UNIX
                hana::make_pair(
                    BOOST_HANA_STRING("unix"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &unix_key);
                        return 2;
                    }
                ),
#endif // BOOST_OS_UNIX
                hana::make_pair(
                    BOOST_HANA_STRING("stream"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &stream_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("regex"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &regex_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("serial_port"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &serial_port_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("tls"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &tls_key);
                        return 2;
                    }
                ),
                hana::make_pair(
                    BOOST_HANA_STRING("system"),
                    [](lua_State* L) -> int {
                        lua_pushboolean(L, 1);
                        rawgetp(L, LUA_REGISTRYINDEX, &system_key);
                        return 2;
                    }
                )
            ),
            on_external_package,
            module_id,
            L
        );
    }
}

std::shared_ptr<vm_context> make_vm(asio::io_context& ioctx,
                                    emilua::app_context& appctx,
                                    fs::path entry_point,
                                    ContextType lua_context)
{
    switch (lua_context) {
    case ContextType::regular_context:
    case ContextType::error_category:
        throw exception{errc::bad_root_context};
    case ContextType::main:
    case ContextType::test:
    case ContextType::worker:
        break;
    }

    if (!entry_point.is_absolute())
        entry_point = fs::absolute(std::move(entry_point));

    // Given we do `foo.parent_path() / (module_id + .lua)` to find the module
    // file the path separator might change the target string and hinder our
    // ECYCLE detection. Normalizing the path before it even enters the module
    // stack fixes the issue.
    entry_point.make_preferred();

#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 1 || \
    EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 0
    strand_type strand{ioctx.get_executor()};
#else
    strand_type strand{ioctx};
#endif
    auto state = std::make_shared<vm_context>(appctx, strand);
    assert(state->valid());

    lua_State* L = state->L();
    lua_gc(L, LUA_GCSTOP, 0);
    BOOST_SCOPE_EXIT_ALL(L) {
        lua_gc(L, LUA_GCRESTART, 0);
    };

    {
        lua_pushlightuserdata(L, &detail::context_key);
        lua_pushlightuserdata(L, state.get());
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &yield_reason_is_native_key);
        lua_pushboolean(L, 1);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &detail::error_category_mt_key);
        lua_createtable(L, /*narr=*/0, /*nrec=*/4);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "error_category");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__eq");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                auto cat1 = static_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat1);
                auto cat2 = static_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat2);
                return *cat1 == *cat2;
            }
        );
        lua_rawset(L, -3);

        lua_pushliteral(L, "__tostring");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                auto cat = static_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat);
                lua_pushstring(L, (*cat)->name());
                return 1;
            }
        );
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                auto cat = static_cast<std::error_category**>(
                    lua_touserdata(L, 1));
                assert(cat);
                auto key = tostringview(L, 2);
                if (key == "message") {
                    lua_pushlightuserdata(L, *cat);
                    lua_pushcclosure(
                        L,
                        [](lua_State* L) -> int {
                            luaL_checktype(L, 1, LUA_TNUMBER);
                            auto cat = static_cast<std::error_category*>(
                                lua_touserdata(L, lua_upvalueindex(1)));
                            push(L, cat->message(lua_tonumber(L, 1)));
                            return 1;
                        },
                        1
                    );
                    return 1;
                } else {
                    push(L, errc::bad_index, "index", 2);
                    return lua_error(L);
                }
            }
        );
        lua_rawset(L, -3);

        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &detail::error_code_mt_key);
        lua_createtable(L, /*narr=*/0, /*nrec=*/4);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "error_code");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        {
            lua_createtable(L, /*narr=*/0, /*nrec=*/1);

            lua_pushliteral(L, "togeneric");
            lua_pushcclosure(
                L,
                [](lua_State* L) -> int {
                    luaL_checktype(L, 1, LUA_TTABLE);
                    lua_getfield(L, 1, "code");
                    int code = luaL_checkinteger(L, -1);

                    lua_getfield(L, 1, "category");
                    auto cat = static_cast<std::error_category**>(
                        lua_touserdata(L, -1));
                    if (!cat || !lua_getmetatable(L, -1)) {
                        push(L, std::errc::invalid_argument, "arg", 1);
                        return lua_error(L);
                    }
                    rawgetp(L, LUA_REGISTRYINDEX,
                            &detail::error_category_mt_key);
                    if (!lua_rawequal(L, -1, -2)) {
                        push(L, std::errc::invalid_argument, "arg", 1);
                        return lua_error(L);
                    }

                    auto c = (*cat)->default_error_condition(code);
                    std::error_code ec{c.value(), c.category()};
                    push(L, ec);
                    return 1;
                },
                0);
            lua_rawset(L, -3);
        }
        lua_rawset(L, -3);

        lua_pushliteral(L, "__eq");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                luaL_checktype(L, 1, LUA_TTABLE);
                luaL_checktype(L, 2, LUA_TTABLE);
                lua_pushliteral(L, "code");
                lua_pushvalue(L, -1);
                lua_rawget(L, 1);
                lua_pushvalue(L, -2);
                lua_rawget(L, 2);
                if (!lua_rawequal(L, -1, -2)) {
                    lua_pushboolean(L, 0);
                    return 1;
                }
                lua_pushliteral(L, "category");
                lua_pushvalue(L, -1);
                lua_rawget(L, 1);
                lua_pushvalue(L, -2);
                lua_rawget(L, 2);
                lua_pushboolean(L, lua_equal(L, -1, -2));
                return 1;
            }
        );
        lua_rawset(L, -3);

        lua_pushliteral(L, "__tostring");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                luaL_checktype(L, 1, LUA_TTABLE);
                lua_pushliteral(L, "code");
                lua_rawget(L, 1);
                if (lua_type(L, -1) != LUA_TNUMBER) {
                    push(L, std::errc::invalid_argument);
                    return lua_error(L);
                }
                int val = lua_tonumber(L, -1);
                lua_pushliteral(L, "category");
                lua_rawget(L, 1);
                if (!lua_getmetatable(L, -1)) {
                    push(L, std::errc::invalid_argument);
                    return lua_error(L);
                }
                rawgetp(L, LUA_REGISTRYINDEX, &detail::error_category_mt_key);
                if (!lua_rawequal(L, -1, -2)) {
                    push(L, std::errc::invalid_argument);
                    return lua_error(L);
                }
                auto cat = static_cast<std::error_category**>(
                    lua_touserdata(L, -3));
                assert(cat);
                push(L, (*cat)->message(val));
                return 1;
            }
        );
        lua_rawset(L, -3);

        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    lua_pushlightuserdata(L, &detail::rdf_error_category_module_mt_key);
    {
        lua_createtable(L, /*narr=*/0, /*nrec=*/2);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "rdf_error_category_module");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        lua_pushcclosure(
            L,
            [](lua_State* L) -> int {
                const auto& cat = **static_cast<const rdf_error_category**>(
                    lua_touserdata(L, 1));
                switch (lua_type(L, 2)) {
                case LUA_TNUMBER: {
                    std::error_code ec(lua_tointeger(L, 2), cat);
                    push(L, ec);
                    return 1;
                    break;
                }
                case LUA_TSTRING: {
                    auto key = tostringview(L, 2);
                    if (
                        auto it = cat.aliases.find(key) ;
                        it != cat.aliases.end()
                    ) {
                        std::error_code ec{it->second, cat};
                        push(L, ec);
                        return 1;
                    } else {
                        push(L, errc::bad_index, "index", 2);
                        return lua_error(L);
                    }
                    break;
                }
                default:
                    push(L, errc::bad_index, "index", 2);
                    return lua_error(L);
                }
            },
            0
        );
        lua_rawset(L, -3);
    }
    lua_rawset(L, LUA_REGISTRYINDEX);

    {
        lua_pushlightuserdata(L, &loaded_modules_key);
        lua_createtable(L, /*narr=*/0, /*nrec=*/0);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_createtable(L, /*narr=*/0, /*nrec=*/0);

        lua_pushlightuserdata(L, &fiber_list_key);
        lua_pushvalue(L, -2);
        lua_rawset(L, LUA_REGISTRYINDEX);

        lua_pushthread(L);
        lua_createtable(
            L,
            /*narr=*/EMILUA_IMPL_INITIAL_MODULE_FIBER_DATA_CAPACITY,
            /*nrec=*/0);

        lua_createtable(L, /*narr=*/1, /*nrec=*/0);
        push(L, entry_point);
        lua_pushvalue(L, -1);
        lua_rawseti(L, -4, FiberDataIndex::SOURCE_PATH);
        lua_rawseti(L, -2, 1);
        lua_rawseti(L, -2, FiberDataIndex::STACK);

        lua_pushboolean(L, 0);
        lua_rawseti(L, -2, FiberDataIndex::LEAF);

        lua_pushinteger(L, lua_context);
        lua_rawseti(L, -2, FiberDataIndex::CONTEXT);

        // when boolean (i.e. not integer), lua code requests to change this
        // setting are ignored
        lua_pushboolean(L, 1);
        lua_rawseti(L, -2, FiberDataIndex::INTERRUPTION_DISABLED);

        lua_pushboolean(L, 0);
        lua_rawseti(L, -2, FiberDataIndex::JOINER);

        lua_newtable(L);
        lua_rawseti(L, -2, FiberDataIndex::LOCAL_STORAGE);

        lua_rawset(L, -3);
        lua_pop(L, 1);
    }

    lua_pushcfunction(L, luaopen_base);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_string);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_table);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_math);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_bit);
    lua_call(L, 0, 0);
    lua_pushcfunction(L, luaopen_jit);
    lua_call(L, 0, 0);

    lua_pushlightuserdata(L, &raw_unpack_key);
    lua_pushliteral(L, "unpack");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_xpcall_key);
    lua_pushliteral(L, "xpcall");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_pcall_key);
    lua_pushliteral(L, "pcall");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_error_key);
    lua_pushliteral(L, "error");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_type_key);
    lua_pushliteral(L, "type");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_pairs_key);
    lua_pushliteral(L, "pairs");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_ipairs_key);
    lua_pushliteral(L, "ipairs");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_next_key);
    lua_pushliteral(L, "next");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_setmetatable_key);
    lua_pushliteral(L, "setmetatable");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &raw_getmetatable_key);
    lua_pushliteral(L, "getmetatable");
    lua_rawget(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    {
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(require_bytecode),
            require_bytecode_size, nullptr);
        assert(res == 0); boost::ignore_unused(res);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
        lua_pushcfunction(L, require);
        lua_call(L, 2, 1);
    }
    lua_setglobal(L, "require");

#if BOOST_OS_WINDOWS
    lua_pushcfunction(L, emilua::lua_print);
    lua_setglobal(L, "print");
#endif

    // core modules (don't change order here) {{{
    init_async_base(L);
    init_scope_cleanup_module(L);
    init_lua_shim_module(L);
    init_fiber_module(L);
    init_mutex_module(L);
    init_condition_variable_module(L);
    init_actor_module(L);

#if BOOST_OS_UNIX
    init_file_descriptor(L);
#endif // BOOST_OS_UNIX
    // }}}

    // extra modules {{{
    init_time(L);
    init_filesystem(L);
    init_json_module(L);
    init_ip(L);
    init_tls(L);
    init_system(L);
    init_byte_span(L);
    init_serial_port(L);
    init_regex(L);
    init_stream(L); //< scanner depends on regex mt
    init_pipe(L);

#if BOOST_OS_UNIX
    init_unix(L);
#endif // BOOST_OS_UNIX

#if EMILUA_CONFIG_ENABLE_HTTP
    init_http(L);
    init_websocket(L);
#endif // EMILUA_CONFIG_ENABLE_HTTP

#if EMILUA_CONFIG_ENABLE_FILE_IO
    init_file(L);
#endif // EMILUA_CONFIG_ENABLE_FILE_IO
    // }}}

    rawgetp(L, LUA_REGISTRYINDEX, &byte_span_key);
    lua_setglobal(L, "byte_span");

    // default_modules_key {{{
    lua_pushliteral(L, "_G");
    lua_pushnil(L);
    lua_rawset(L, LUA_GLOBALSINDEX);

    lua_pushlightuserdata(L, &default_modules_key);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_newtable(L);
    lua_replace(L, LUA_GLOBALSINDEX);

    rawgetp(L, LUA_REGISTRYINDEX, &default_modules_key);
    lua_pushnil(L);
    while (lua_next(L, -2) != 0) {
        lua_pushvalue(L, -2);
        lua_insert(L, -2);
        lua_rawset(L, LUA_GLOBALSINDEX);
    }
    lua_pop(L, 1);

    lua_pushliteral(L, "_G");
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_rawset(L, LUA_GLOBALSINDEX);
    // }}}

    {
        std::string_view ctx_str;
        switch (lua_context) {
        case ContextType::regular_context:
        case ContextType::error_category:
            assert(false);
            break;
        case ContextType::main:
            ctx_str = "main";
            break;
        case ContextType::test:
            ctx_str = "test";
            break;
        case ContextType::worker:
            ctx_str = "worker";
            break;
        }
        push(L, ctx_str);
        lua_setglobal(L, "_CONTEXT");
    }

    // async_event_thread
    {
        lua_State* async_event_thread = lua_newthread(L);
        init_new_coro_or_fiber_scope(async_event_thread, L);

        rawgetp(async_event_thread, LUA_REGISTRYINDEX, &fiber_list_key);
        lua_pushthread(async_event_thread);
        lua_createtable(
            async_event_thread,
            /*narr=*/EMILUA_IMPL_INITIAL_FIBER_DATA_CAPACITY,
            /*nrec=*/0);
        {
            lua_pushboolean(async_event_thread, 1);
            lua_rawseti(async_event_thread, -2,
                        FiberDataIndex::INTERRUPTION_DISABLED);

            lua_pushinteger(async_event_thread, 1);
            lua_rawseti(async_event_thread, -2,
                        FiberDataIndex::SUSPENSION_DISALLOWED);

            lua_pushboolean(async_event_thread, 0);
            lua_rawseti(async_event_thread, -2, FiberDataIndex::JOINER);

            push(async_event_thread, entry_point);
            lua_rawseti(async_event_thread, -2, FiberDataIndex::SOURCE_PATH);
        }
        lua_rawset(async_event_thread, -3);
        state->async_event_thread(async_event_thread);
        lua_pop(async_event_thread, 1);
        lua_pop(L, 1);
    }

    std::string& module_source = load_module_source(state->appctx, entry_point);

    {
        lua_pushlightuserdata(L, &module_start_fn_key);
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(module_start_fn_bytecode),
            module_start_fn_bytecode_size, nullptr);
        assert(res == 0); boost::ignore_unused(res);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(start_fn_bytecode),
            start_fn_bytecode_size, nullptr);
        assert(res == 0); boost::ignore_unused(res);
        lua_pushcfunction(L, root_scope);
        lua_pushcfunction(L, set_current_traceback);
        lua_pushcfunction(L, terminate_vm_with_cleanup_error);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_xpcall_key);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_pcall_key);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
    }

    std::string name{'@'};
    {
        auto u8name = entry_point.u8string();
        name.append(reinterpret_cast<char*>(u8name.data()), u8name.size());
    }
    switch (int res = luaL_loadbuffer(
        L, module_source.data(), module_source.size(), name.data()
    ) ; res) {
    case 0:
        break;
    case LUA_ERRMEM:
        throw std::bad_alloc();
    default: {
        std::size_t len;
        const char* str = lua_tolstring(L, -1, &len);
        throw lua_exception{res, std::string{str, len}};
    }
    }

    int res = lua_pcall(L, 7, 1, 0);
    if (res == LUA_ERRMEM)
        throw std::bad_alloc();
    assert(res == 0);

    return state;
}

} // namespace emilua

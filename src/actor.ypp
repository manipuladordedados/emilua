/* Copyright (c) 2020, 2021, 2023 Vin√≠cius dos Santos Oliveira

   Distributed under the Boost Software License, Version 1.0. (See accompanying
   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) */

#include <optional>
#include <thread>

#include <boost/scope_exit.hpp>

#include <emilua/async_base.hpp>
#include <emilua/filesystem.hpp>
#include <emilua/windows.hpp>
#include <emilua/actor.hpp>
#include <emilua/state.hpp>
#include <emilua/fiber.hpp>
#include <emilua/json.hpp>

#include <boost/hana/functional/overload.hpp>

#if BOOST_OS_UNIX
#include <emilua/file_descriptor.hpp>

#include <boost/serialization/unordered_map.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <sys/wait.h>
#endif // BOOST_OS_UNIX

namespace emilua {

namespace fs = std::filesystem;

extern unsigned char chan_op_bytecode[];
extern std::size_t chan_op_bytecode_size;

char inbox_key;
static char inbox_mt_key;
static char tx_chan_mt_key;
static char closed_tx_chan_mt_key;
static char chan_receive_key;
static char chan_send_key;

#if BOOST_OS_UNIX
char ipc_actor_chan_mt_key;
static char ipc_actor_chan_send_key;

struct ipc_actor_send_op
    : public std::enable_shared_from_this<ipc_actor_send_op>
{
    struct file_descriptor_lock
    {
        file_descriptor_lock() = default;
        file_descriptor_lock(const file_descriptor_lock&) = delete;
        file_descriptor_lock& operator=(const file_descriptor_lock&) = delete;

        file_descriptor_handle* reference = nullptr;
        file_descriptor_handle value = INVALID_FILE_DESCRIPTOR;
    };

    ipc_actor_send_op(emilua::vm_context& vm_ctx,
                      asio::cancellation_slot cancel_slot,
                      asio::local::datagram_protocol::socket& sock)
        : sock{sock}
        , current_fiber{vm_ctx.current_fiber()}
        , vm_ctx{vm_ctx.shared_from_this()}
        , cancel_slot{std::move(cancel_slot)}
    {}

    void do_wait()
    {
        sock.async_wait(
            asio::socket_base::wait_write,
            asio::bind_cancellation_slot(cancel_slot, asio::bind_executor(
                vm_ctx->strand_using_defer(),
                [self=shared_from_this()](const boost::system::error_code& ec) {
                    self->on_wait(ec);
                }
            ))
        );
    }

    void on_wait(const boost::system::error_code& ec)
    {
        using descriptors_size_type = decltype(descriptors_size);
        if (!vm_ctx->valid()) {
            for (descriptors_size_type i = 0 ; i != descriptors_size ; ++i) {
                int res = close(descriptors[i].value);
                boost::ignore_unused(res);
            }
            return;
        }

        if (ec) {
            for (descriptors_size_type i = 0 ; i != descriptors_size ; ++i) {
                if (descriptors[i].reference) {
                    *descriptors[i].reference = descriptors[i].value;
                } else {
                    int res = close(descriptors[i].value);
                    boost::ignore_unused(res);
                }
            }
            vm_ctx->fiber_resume(
                current_fiber,
                hana::make_set(
                    vm_context::options::auto_detect_interrupt,
                    hana::make_pair(opt_args, hana::make_tuple(ec))));
            return;
        }

        struct msghdr msg;
        std::memset(&msg, 0, sizeof(msg));

        assert(message_size <= sizeof(message) && message_size > 0);
        struct iovec iov;
        iov.iov_base = &message;
        iov.iov_len = message_size;
        msg.msg_iov = &iov;
        msg.msg_iovlen = 1;

        union
        {
            struct cmsghdr align;
            char buf[CMSG_SPACE(
                sizeof(int) *
                EMILUA_CONFIG_IPC_ACTOR_MESSAGE_MAX_MEMBERS_NUMBER)];
        } cmsgu;
        msg.msg_control = cmsgu.buf;
        msg.msg_controllen = CMSG_SPACE(sizeof(int) * descriptors_size);

        struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
        cmsg->cmsg_level = SOL_SOCKET;
        cmsg->cmsg_type = SCM_RIGHTS;
        cmsg->cmsg_len = CMSG_LEN(sizeof(int) * descriptors_size);
        {
            char* out = (char*)CMSG_DATA(cmsg);
            for (auto& fdlock: descriptors) {
                std::memcpy(out, &fdlock.value, sizeof(int));
                out += sizeof(int);
            }
        }

        auto nwritten = sendmsg(sock.native_handle(), &msg,
                                MSG_DONTWAIT | MSG_NOSIGNAL);
        int send_errno = errno;
        if (
            nwritten == -1 &&
            (send_errno == EAGAIN || send_errno == EWOULDBLOCK)
        ) {
            do_wait();
            return;
        }
        for (descriptors_size_type i = 0 ; i != descriptors_size ; ++i) {
            if (descriptors[i].reference) {
                *descriptors[i].reference = descriptors[i].value;
            } else {
                int res = close(descriptors[i].value);
                boost::ignore_unused(res);
            }
        }

        if (nwritten == -1) {
            std::error_code ec2{send_errno, std::system_category()};
            vm_ctx->fiber_resume(
                current_fiber,
                hana::make_set(
                    hana::make_pair(opt_args, hana::make_tuple(ec2))));
            return;
        }

        vm_ctx->fiber_resume(current_fiber);
    }

    asio::local::datagram_protocol::socket& sock;
    lua_State* current_fiber;
    std::shared_ptr<emilua::vm_context> vm_ctx;
    asio::cancellation_slot cancel_slot;
    ipc_actor_message message;
    std::size_t message_size;
    std::array<
        file_descriptor_lock,
        EMILUA_CONFIG_IPC_ACTOR_MESSAGE_MAX_MEMBERS_NUMBER
    > descriptors;
    std::uint8_t descriptors_size = 0;

    static constexpr auto opt_args = vm_context::options::arguments;
};
#endif // BOOST_OS_UNIX

static int deserializer_closure(lua_State* L)
{
    using array_key_type = int;

    struct object_range
    {
        using iterator =
            typename std::map<std::string, inbox_t::value_type>::iterator;

        object_range(std::map<std::string, inbox_t::value_type>& m)
            : it{m.begin()}
            , end{m.end()}
        {}

        bool empty() const
        {
            return it == end;
        }

        iterator it;
        iterator end;
    };

    struct array_range
    {
        array_range(std::vector<inbox_t::value_type>& array)
            : array{array}
        {
            assert(array.size() <= std::numeric_limits<array_key_type>::max());
        }

        bool empty() const
        {
            return idx == array.size();
        }

        std::size_t idx = 0;
        std::vector<inbox_t::value_type>& array;
    };

    auto& value = *static_cast<inbox_t::value_type*>(
        lua_touserdata(L, lua_upvalueindex(1)));

    std::vector<std::variant<object_range, array_range>> path;

    static constexpr auto push_address = [](lua_State* L, actor_address& a) {
        auto buf = static_cast<actor_address*>(
            lua_newuserdata(L, sizeof(actor_address))
        );
        rawgetp(L, LUA_REGISTRYINDEX, &tx_chan_mt_key);
        setmetatable(L, -2);
        new (buf) actor_address{std::move(a)};
    };

#if BOOST_OS_UNIX
    static constexpr auto push_file_descriptor = [](
        lua_State* L, std::shared_ptr<inbox_t::file_descriptor_box>& fdbox
    ) {
        assert(fdbox->value != -1);

        auto fdhandle = static_cast<file_descriptor_handle*>(
            lua_newuserdata(L, sizeof(file_descriptor_handle))
        );
        rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
        setmetatable(L, -2);

        *fdhandle = fdbox->value;
        fdbox->value = -1;
    };

    static constexpr auto push_ipc_actor_address = [](
        lua_State* L, inbox_t::ipc_actor_address& a
    ) {
        assert(a.inbox->value != -1);

        auto& vm_ctx = get_vm_context(L);
        auto ch = static_cast<ipc_actor_address*>(
            lua_newuserdata(L, sizeof(ipc_actor_address))
        );
        rawgetp(L, LUA_REGISTRYINDEX, &ipc_actor_chan_mt_key);
        setmetatable(L, -2);
        new (ch) ipc_actor_address{vm_ctx.strand().context()};

        asio::local::datagram_protocol protocol;
        boost::system::error_code ignored_ec;
        ch->dest.assign(protocol, a.inbox->value, ignored_ec);
        assert(!ignored_ec);
        a.inbox->value = -1;
    };
#endif // BOOST_OS_UNIX

    auto push_leaf_or_append_path_and_return_true_on_leaf = [&](
        inbox_t::value_type::variant_type& value
    ) {
        return std::visit(hana::overload(
            [L](bool b) { lua_pushboolean(L, b ? 1 : 0); return true; },
            [L](lua_Number n) { lua_pushnumber(L, n); return true;},
            [L](std::string_view v) { push(L, v); return true; },
            [L](actor_address& a) { push_address(L, a); return true; },
#if BOOST_OS_UNIX
            [L](std::shared_ptr<inbox_t::file_descriptor_box>& fdbox) {
                push_file_descriptor(L, fdbox); return true;
            },
            [L](inbox_t::ipc_actor_address& a) {
                push_ipc_actor_address(L, a); return true;
            },
#endif // BOOST_OS_UNIX
            [&](std::map<std::string, inbox_t::value_type>& m) {
                path.emplace_back(std::in_place_type<object_range>, m);
                return false;
            },
            [&](std::vector<inbox_t::value_type>& v) {
                path.emplace_back(std::in_place_type<array_range>, v);
                return false;
            }
        ), value);
    };
    if (/*is_leaf=*/push_leaf_or_append_path_and_return_true_on_leaf(value))
        return 1;

    // During `value` traversal, we always keep two values on top of the lua
    // stack (from top to bottom):
    //
    // * -1: Current work item.
    // * -2: The items tree stack.
    //
    // See `json::decode()` implementation for details. It's kinda the same
    // layout idea. There's an explanation comment block there already. Do
    // notice there are major differences between JSON and `value` traversal
    // (e.g. key-value pair available in one-shot vs pieces, untrusted vs
    // pre-sanitized data, cheapness of look-ahead, requirement to mark arrays
    // with special metatable, etc) so the traversal algorithm accordingly
    // deviates a lot (e.g. current work item is never nil, ...).
    lua_newtable(L);
    lua_newtable(L);
    lua_pushvalue(L, -1);
    lua_rawseti(L, -3, 1);

    for (;;) {
        assert(lua_type(L, -1) == LUA_TTABLE);
        inbox_t::value_type::variant_type *value = nullptr;
        std::visit(hana::overload(
            [&](object_range& o) {
                if (o.empty())
                    return;

                push(L, o.it->first);
                value = &o.it->second;
                ++o.it;
            },
            [&](array_range& a) {
                if (a.empty())
                    return;

                lua_pushinteger(L, a.idx + 1);
                value = &a.array[a.idx];
                ++a.idx;
            }
        ), path.back());
        if (!value) { // close event
            path.pop_back();
            if (path.size() == 0)
                break;

            lua_pop(L, 1);
            lua_pushnil(L);
            lua_rawseti(L, -2, static_cast<array_key_type>(path.size() + 1));
            lua_rawgeti(L, -1, static_cast<array_key_type>(path.size()));
            continue;
        }
        if (push_leaf_or_append_path_and_return_true_on_leaf(*value)) {
            lua_rawset(L, -3);
            continue;
        }
        lua_newtable(L);
        lua_insert(L, -2);
        lua_pushvalue(L, -2);
        lua_rawset(L, -4);
        lua_remove(L, -2);
        lua_pushvalue(L, -1);
        lua_rawseti(L, -3, static_cast<array_key_type>(path.size()));
    }

    assert(lua_objlen(L, -2) == 1);
    return 1;
}

static int chan_send(lua_State* L)
{
    if (lua_gettop(L) < 2) {
        push(L, std::errc::invalid_argument);
        return lua_error(L);
    }

    auto& vm_ctx = get_vm_context(L);
    auto handle = static_cast<actor_address*>(lua_touserdata(L, 1));
    if (!handle || !lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &tx_chan_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    EMILUA_CHECK_SUSPEND_ALLOWED(vm_ctx, L);

    auto dest_vm_ctx = handle->dest.lock();
    if (!dest_vm_ctx) {
        push(L, errc::channel_closed);
        return lua_error(L);
    }

    using array_key_type = int;
    constexpr auto array_key_max = std::numeric_limits<array_key_type>::max();

    enum {
        NODE_IDX = 1,
        ITER_IDX,
    };

    static constexpr std::uintptr_t is_object_bitmask = 0x1;
    static_assert(sizeof(std::uintptr_t) == sizeof(void*));
    // number of bits we can hijack from pointer for our own purposes {{{
    static_assert(alignof(inbox_t::value_object_type) > 1);
    static_assert(alignof(inbox_t::value_array_type) > 1);
    // }}}

    struct dom_reference
    {
        dom_reference(inbox_t::value_object_type& o)
            : ptr{reinterpret_cast<std::uintptr_t>(&o) | is_object_bitmask}
        {}

        dom_reference(inbox_t::value_array_type& a)
            : ptr{reinterpret_cast<std::uintptr_t>(&a)}
        {}

        inbox_t::value_object_type& as_object()
        {
            return *reinterpret_cast<inbox_t::value_object_type*>(
                ptr & ~is_object_bitmask);
        }

        inbox_t::value_array_type& as_array()
        {
            return *reinterpret_cast<inbox_t::value_array_type*>(ptr);
        }

        bool is_object() const
        {
            return ptr & is_object_bitmask;
        }

        bool is_array() const
        {
            return !is_object();
        }

        std::uintptr_t ptr;
    };

    inbox_t::sender_state sender{vm_ctx};

    switch (lua_type(L, 2)) {
    case LUA_TNIL:
    case LUA_TFUNCTION:
    case LUA_TTHREAD:
    case LUA_TLIGHTUSERDATA:
        push(L, std::errc::invalid_argument);
        return lua_error(L);
    case LUA_TNUMBER:
        sender.msg.emplace<lua_Number>(lua_tonumber(L, 2));
        break;
    case LUA_TBOOLEAN:
        sender.msg.emplace<bool>(lua_toboolean(L, 2));
        break;
    case LUA_TSTRING: {
        std::size_t size;
        const char* data = lua_tolstring(L, 2, &size);
        sender.msg.emplace<std::string>(data, size);
        break;
    }
    case LUA_TTABLE: {
        if (lua_getmetatable(L, 2)) {
            push(L, std::errc::invalid_argument);
            return lua_error(L);
        }

        std::vector<dom_reference> dom_stack;
        array_key_type current_array_idx;

        // During iteration, we keep 3 values as the Lua stack base (from bottom
        // to top):
        //
        // * A visited table to detect reference cycles.
        // * The iterators stack (our iteration tree). Each element is a Lua
        //   table (a work item).
        // * The current Lua table being iterated.
        //
        // If current work item is an object, we keep 1 extra value on the Lua
        // stack top:
        //
        // * Current key.
        lua_newtable(L);
        lua_pushvalue(L, 2);
        lua_pushboolean(L, 1);
        lua_rawset(L, -3);

        lua_newtable(L);
        lua_pushvalue(L, 2);

        {
            lua_createtable(L, /*narr=*/2, /*nrec=*/0);
            lua_pushvalue(L, -2);
            lua_rawseti(L, -2, NODE_IDX);
        }
        lua_rawseti(L, -3, 1);

        if (lua_objlen(L, -1) > 0) {
            dom_stack.emplace_back(
                sender.msg.emplace<inbox_t::value_array_type>());
            current_array_idx = 0;
        } else {
            dom_stack.emplace_back(
                sender.msg.emplace<inbox_t::value_object_type>());
            lua_pushnil(L);
        }

        while (dom_stack.size() > 0) {
            auto cur_node = dom_stack.back();
            inbox_t::value_type *cur_value = nullptr;
            inbox_t::value_object_type::iterator obj_it;
            if (cur_node.is_array()) {
                if (current_array_idx == array_key_max) {
                    push(L, json_errc::array_too_long);
                    return lua_error(L);
                }

                lua_rawgeti(L, -1, ++current_array_idx);
                switch (lua_type(L, -1)) {
                case LUA_TNIL:
                    lua_pop(L, 1);
                    break;
                default:
                    cur_value = &cur_node.as_array().emplace_back(
                        std::in_place_type<bool>, false);
                }
            } else {
                if (lua_next(L, -2) != 0) {
                    if (lua_type(L, -2) != LUA_TSTRING) {
                        lua_pop(L, 1);
                        continue;
                    }
                    obj_it = cur_node.as_object().emplace(
                        tostringview(L, -2), false).first;
                    cur_value = &obj_it->second;
                }
            }

            auto update_lua_ctx_on_level_popped = [&]() {
                // remove from visited
                lua_pushnil(L);
                lua_rawset(L, -4);

                // update iterators stack {{{
                lua_pushnil(L);
                lua_rawseti(L, -2,
                            static_cast<array_key_type>(dom_stack.size() + 1));
                // }}}

                // update cur table + iterator
                lua_rawgeti(L, -1,
                            static_cast<array_key_type>(dom_stack.size()));
                lua_rawgeti(L, -1, NODE_IDX);
                lua_rawgeti(L, -2, ITER_IDX);
                lua_remove(L, -3);
                if (dom_stack.back().is_array()) {
                    current_array_idx = lua_tointeger(L, -1);
                    lua_pop(L, 1);
                }
            };

            // event: close current node
            if (!cur_value) {
                dom_stack.pop_back();
                if (dom_stack.size() == 0)
                    break;

                update_lua_ctx_on_level_popped();
                continue;
            }

            auto ignore_cur_item = [&]() {
                lua_pop(L, 1);
                if (cur_node.is_array()) {
                    cur_node.as_array().pop_back();

                    dom_stack.pop_back();
                    if (dom_stack.size() == 0)
                        return;

                    update_lua_ctx_on_level_popped();
                } else {
                    cur_node.as_object().erase(obj_it);
                }
            };

            switch (lua_type(L, -1)) {
            case LUA_TNIL:
                assert(false);
            case LUA_TUSERDATA:
                if (lua_getmetatable(L, -1)) {
                    rawgetp(L, LUA_REGISTRYINDEX, &tx_chan_mt_key);
                    if (lua_rawequal(L, -1, -2)) {
                        const auto& msg = *static_cast<actor_address*>(
                            lua_touserdata(L, -3));
                        cur_value->emplace<actor_address>(msg);
                        lua_pop(L, 3);
                        break;
                    }
                    rawgetp(L, LUA_REGISTRYINDEX, &inbox_mt_key);
                    if (lua_rawequal(L, -1, -3)) {
                        cur_value->emplace<actor_address>(vm_ctx);
                        lua_pop(L, 4);
                        break;
                    }
#if BOOST_OS_UNIX
                    rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
                    if (lua_rawequal(L, -1, -4)) {
                        auto msg = *static_cast<file_descriptor_handle*>(
                            lua_touserdata(L, -5));
                        if (msg != -1) {
                            int newfd = dup(msg);
                            if (newfd == -1) {
                                std::error_code ec{
                                    errno, std::system_category()};
                                push(L, ec);
                                return lua_error(L);
                            }

                            cur_value->emplace<
                                std::shared_ptr<inbox_t::file_descriptor_box>
                            >(std::make_shared<inbox_t::file_descriptor_box>(
                                newfd
                            ));
                            lua_pop(L, 5);
                            break;
                        }
                    }
#endif // BOOST_OS_UNIX
                    // TODO: check whether has metamethod to transfer between
                    // states
#if BOOST_OS_UNIX
                    lua_pop(L, 4);
#else
                    lua_pop(L, 3);
#endif // BOOST_OS_UNIX
                }
                [[fallthrough]];
            case LUA_TFUNCTION:
            case LUA_TTHREAD:
            case LUA_TLIGHTUSERDATA:
                ignore_cur_item();
                break;
            case LUA_TNUMBER:
                cur_value->emplace<lua_Number>(lua_tonumber(L, -1));
                lua_pop(L, 1);
                break;
            case LUA_TBOOLEAN:
                cur_value->emplace<bool>(lua_toboolean(L, -1));
                lua_pop(L, 1);
                break;
            case LUA_TSTRING:
                cur_value->emplace<std::string>(tostringview(L, -1));
                lua_pop(L, 1);
                break;
            case LUA_TTABLE: {
                if (lua_getmetatable(L, -1)) {
                    lua_pop(L, 1);
                    ignore_cur_item();
                    break;
                }

                {
                    int visited_idx = cur_node.is_array() ? -4 : -5;
                    lua_pushvalue(L, -1);
                    lua_rawget(L, visited_idx - 1);
                    if (lua_type(L, -1) == LUA_TBOOLEAN) {
                        assert(lua_toboolean(L, -1) == 1);
                        push(L, json_errc::cycle_exists);
                        return lua_error(L);
                    }
                    assert(lua_type(L, -1) == LUA_TNIL);
                    lua_pop(L, 1);

                    lua_pushvalue(L, -1);
                    lua_pushboolean(L, 1);
                    lua_rawset(L, visited_idx - 2);
                }

                if (dom_stack.size() == array_key_max) {
                    push(L, json_errc::too_many_levels);
                    return lua_error(L);
                }

                // save current iterator
                {
                    int iterators_stack_idx = cur_node.is_array() ? -3 : -4;
                    lua_rawgeti(L, iterators_stack_idx,
                                static_cast<array_key_type>(dom_stack.size()));
                    if (cur_node.is_array())
                        lua_pushinteger(L, current_array_idx);
                    else
                        lua_pushvalue(L, -3);
                    lua_rawseti(L, -2, ITER_IDX);
                    lua_pop(L, 1);
                }

                // remove iter/key from Lua stack (only there on objects)
                if (cur_node.is_object())
                    lua_remove(L, -2);

                // remove from the Lua stack, the node that we were previously
                // iterating over
                lua_remove(L, -2);

                {
                    lua_createtable(L, /*narr=*/2, /*nrec=*/0);
                    lua_pushvalue(L, -2);
                    lua_rawseti(L, -2, NODE_IDX);
                }
                lua_rawseti(L, -3,
                            static_cast<array_key_type>(dom_stack.size() + 1));

                if (lua_objlen(L, -1) > 0) {
                    dom_stack.emplace_back(
                        cur_value->emplace<inbox_t::value_array_type>());
                    current_array_idx = 0;
                } else {
                    dom_stack.emplace_back(
                        cur_value->emplace<inbox_t::value_object_type>());
                    lua_pushnil(L);
                }
            }
            }
        }
        lua_pop(L, 3);
        break;
    }
    case LUA_TUSERDATA:
        if (!lua_getmetatable(L, 2)) {
            push(L, std::errc::invalid_argument);
            return lua_error(L);
        }
        if (lua_rawequal(L, -1, -2)) {
            const auto& msg = *static_cast<const actor_address*>(
                lua_touserdata(L, 2));
            sender.msg.emplace<actor_address>(msg);
            break;
        }
        rawgetp(L, LUA_REGISTRYINDEX, &inbox_mt_key);
        if (lua_rawequal(L, -1, -2)) {
            sender.msg.emplace<actor_address>(vm_ctx);
            break;
        }
#if BOOST_OS_UNIX
        rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
        if (lua_rawequal(L, -1, -3)) {
            auto msg = *static_cast<file_descriptor_handle*>(
                lua_touserdata(L, 2));
            if (msg == -1) {
                push(L, std::errc::device_or_resource_busy);
                return lua_error(L);
            }

            int newfd = dup(msg);
            if (newfd == -1) {
                push(L, std::error_code{errno, std::system_category()});
                return lua_error(L);
            }

            sender.msg.emplace<std::shared_ptr<inbox_t::file_descriptor_box>>(
                std::make_shared<inbox_t::file_descriptor_box>(newfd));
            break;
        }
#endif // BOOST_OS_UNIX
        // TODO: check whether has metamethod to transfer between states
        push(L, std::errc::not_supported);
        return lua_error(L);
    }

    lua_pushvalue(L, 1);
    lua_pushlightuserdata(L, vm_ctx.current_fiber());
    lua_pushcclosure(
        L,
        [](lua_State* L) -> int {
            auto& vm_ctx = get_vm_context(L);
            auto handle = static_cast<const actor_address*>(
                lua_touserdata(L, lua_upvalueindex(1)));
            auto current_fiber = static_cast<lua_State*>(
                lua_touserdata(L, lua_upvalueindex(2)));

            auto dest_vm_ctx = handle->dest.lock();
            if (!dest_vm_ctx)
                return 0;

            inbox_t::sender_state sender{vm_ctx, current_fiber};
            dest_vm_ctx->strand().post(
                [vm_ctx=dest_vm_ctx, sender=std::move(sender)]() {
                    // We rely on FIFO order here. If it were allowed for the
                    // interrupter to arrive before the `sender` delivery, this
                    // algorithm would fail by assuming the task already
                    // finished and there is nothing to interrupt.
                    auto it = std::find(
                        vm_ctx->inbox.incoming.begin(),
                        vm_ctx->inbox.incoming.end(),
                        sender);
                    if (it == vm_ctx->inbox.incoming.end())
                        return;
                    vm_ctx->inbox.incoming.erase(it);

                    sender.vm_ctx->strand().post(
                        [vm_ctx=sender.vm_ctx, fiber=sender.fiber]() {
                            vm_ctx->fiber_resume(
                                fiber,
                                hana::make_set(
                                    hana::make_pair(
                                        vm_context::options::arguments,
                                        hana::make_tuple(errc::interrupted))));
                        },
                        std::allocator<void>{}
                    );
                },
                std::allocator<void>{}
            );
            return 0;
        },
        2
    );
    set_interrupter(L, vm_ctx);

    sender.wake_on_destruct = true;
    dest_vm_ctx->strand().post(
        [vm_ctx=dest_vm_ctx, sender=std::move(sender)]() mutable {
            auto recv_fiber = vm_ctx->inbox.recv_fiber;
            if (!vm_ctx->inbox.open)
                return;

            if (!recv_fiber) {
                vm_ctx->inbox.incoming.emplace_back(std::move(sender));
                vm_ctx->inbox.incoming.back().wake_on_destruct = false;
                return;
            }

            vm_ctx->inbox.recv_fiber = nullptr;
            vm_ctx->inbox.work_guard.reset();

            auto deserializer = [&sender](lua_State* recv_fiber) {
                lua_pushlightuserdata(recv_fiber, &sender.msg);
                lua_pushcclosure(recv_fiber, deserializer_closure, 1);
            };
            vm_ctx->fiber_resume(
                recv_fiber,
                hana::make_set(
                    hana::make_pair(
                        vm_context::options::arguments,
                        hana::make_tuple(std::nullopt, deserializer))));

            sender.wake_on_destruct = false;
            sender.vm_ctx->strand().post(
                [vm_ctx=sender.vm_ctx, fiber=sender.fiber]() {
                    auto opt_args = vm_context::options::arguments;
                    vm_ctx->fiber_resume(
                        fiber,
                        hana::make_set(
                            hana::make_pair(
                                opt_args, hana::make_tuple(std::nullopt))));
                },
                std::allocator<void>{}
            );
        },
        std::allocator<void>{}
    );

    return lua_yield(L, 0);
}

static int tx_chan_close(lua_State* L)
{
    auto handle = static_cast<actor_address*>(lua_touserdata(L, 1));
    if (!handle || !lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &tx_chan_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    rawgetp(L, LUA_REGISTRYINDEX, &closed_tx_chan_mt_key);
    setmetatable(L, 1);
    handle->~actor_address();
    return 0;
}

static int chan_receive(lua_State* L)
{
    auto& vm_ctx = get_vm_context(L);
    if (!lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &inbox_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    EMILUA_CHECK_SUSPEND_ALLOWED(vm_ctx, L);

    if (!vm_ctx.inbox.open) {
        push(L, errc::channel_closed);
        return lua_error(L);
    }

    if (vm_ctx.inbox.recv_fiber != nullptr) {
        push(L, std::errc::device_or_resource_busy);
        return lua_error(L);
    }

    if (vm_ctx.inbox.incoming.size() != 0) {
        lua_pushnil(L);

        auto sender = std::move(vm_ctx.inbox.incoming.front());
        vm_ctx.inbox.incoming.pop_front();

        if (sender.vm_ctx) {
            sender.vm_ctx->strand().post(
                [vm_ctx=sender.vm_ctx, fiber=sender.fiber]() {
                    vm_ctx->fiber_resume(fiber);
                },
                std::allocator<void>{}
            );
        }

        lua_pushlightuserdata(L, &sender.msg);
        lua_pushcclosure(L, deserializer_closure, 1);
        lua_call(L, 0, 1);

        return 2;
    }

    // runtime errors are checked after logical errors
    if (vm_ctx.inbox.nsenders.load() == 0) {
        push(L, errc::no_senders);
        return lua_error(L);
    }

    lua_pushcclosure(
        L,
        [](lua_State* L) -> int {
            auto& vm_ctx = get_vm_context(L);
            auto recv_fiber = vm_ctx.inbox.recv_fiber;

            vm_ctx.inbox.recv_fiber = nullptr;
            vm_ctx.inbox.work_guard.reset();

            vm_ctx.strand().post(
                [vm_ctx=vm_ctx.shared_from_this(), recv_fiber]() {
                    vm_ctx->fiber_resume(
                        recv_fiber,
                        hana::make_set(
                            hana::make_pair(
                                vm_context::options::arguments,
                                hana::make_tuple(errc::interrupted))));
                },
                std::allocator<void>{}
            );

            return 0;
        },
        0
    );
    set_interrupter(L, vm_ctx);

#if BOOST_OS_UNIX
    for (auto& op: vm_ctx.pending_operations) {
        auto service = dynamic_cast<ipc_actor_inbox_service*>(&op);
        if (service)
            service->async_enqueue(vm_ctx);
    }
#endif // BOOST_OS_UNIX

    vm_ctx.inbox.recv_fiber = vm_ctx.current_fiber();
    vm_ctx.inbox.work_guard = vm_ctx.shared_from_this();
    return lua_yield(L, 0);
}

static int inbox_close(lua_State* L)
{
    auto& vm_ctx = get_vm_context(L);
    if (!lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &inbox_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    if (!vm_ctx.inbox.open)
        return 0;

    if (vm_ctx.inbox.recv_fiber != nullptr) {
        auto recv_fiber = vm_ctx.inbox.recv_fiber;

        vm_ctx.inbox.recv_fiber = nullptr;
        vm_ctx.inbox.work_guard.reset();

        vm_ctx.strand().post([vm_ctx=vm_ctx.shared_from_this(), recv_fiber]() {
            auto opt_args = vm_context::options::arguments;
            vm_ctx->fiber_resume(
                recv_fiber,
                hana::make_set(
                    hana::make_pair(
                        opt_args, hana::make_tuple(errc::channel_closed))));
        }, std::allocator<void>{});
    }

    vm_ctx.inbox.open = false;
    for (auto& m: vm_ctx.inbox.incoming) {
        m.wake_on_destruct = true;
    }
    vm_ctx.inbox.incoming.clear();
    return 0;
}

static int inbox_gc(lua_State* L)
{
    auto& vm_ctx = get_vm_context(L);
    if (!vm_ctx.inbox.open)
        return 0;

    // This is only needed if the VM crashes (i.e. nobody woke `recv_fiber` up),
    // but even so there are other layers that will execute this same
    // snippet. Anyway, defensive programming here. This extra safety belt
    // doesn't hurt. {{{
    vm_ctx.inbox.recv_fiber = nullptr;
    vm_ctx.inbox.work_guard.reset();
    // }}}

    vm_ctx.inbox.open = false;
    for (auto& m: vm_ctx.inbox.incoming) {
        m.wake_on_destruct = true;
    }
    vm_ctx.inbox.incoming.clear();
    return 0;
}

static int spawn_vm(lua_State* L)
{
    lua_settop(L, 1);

    auto& vm_ctx = get_vm_context(L);
    std::string_view module;

    switch (lua_type(L, 1)) {
    case LUA_TSTRING:
        module = tostringview(L, 1);
        if (module.size() == 0) {
            push(L, errc::invalid_module_name);
            return lua_error(L);
        }
        break;
    case LUA_TTABLE:
        break;
    default:
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    // get _FILE
    fs::path importer_path;
    {
        lua_Debug ar;
        int res = lua_getstack(L, /*level=*/1, &ar);
        assert(res == 1); boost::ignore_unused(res);
        res = lua_getinfo(L, "f", &ar);
        assert(res != 0);
        if (lua_isnil(L, -1)) {
            return luaL_error(L, "no function environment for tail call");
        }
        lua_getfenv(L, -1);
        lua_getfield(L, -1, "_FILE");

        auto p = static_cast<fs::path*>(lua_touserdata(L, -1));
        if (!p || !lua_getmetatable(L, -1)) {
            push(L, errc::current_module_not_known);
            return lua_error(L);
        }
        rawgetp(L, LUA_REGISTRYINDEX, &filesystem_path_mt_key);
        if (!lua_rawequal(L, -1, -2)) {
            push(L, errc::current_module_not_known);
            return lua_error(L);
        }

        importer_path = *p;
    }
    if (!vm_ctx.import_tree.contains(importer_path)) {
        push(L, errc::current_module_not_known);
        return lua_error(L);
    }
    const auto& import_root = vm_ctx.import_tree[importer_path].import_root;

    bool inherit_ctx = true;
    bool new_master = false;
#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 2
    int concurrency_hint = BOOST_ASIO_CONCURRENCY_HINT_SAFE;
#elif EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 1
    int concurrency_hint = 1;
#endif
#if BOOST_OS_UNIX
    bool run_in_subprocess = false;
    std::unordered_map<std::string, std::string> newenv;
    std::optional<std::string> lua_hook;
    int lua_hook_fd = -1;
    int proc_stdin = -1;
    int proc_stdout = -1;
    int proc_stderr = -1;
    ipc_actor_start_vm_request request;
    std::memset(&request, 0, sizeof(request));
    request.type = ipc_actor_start_vm_request::CREATE_PROCESS;
#endif // BOOST_OS_UNIX

    if (module.size() == 0) {
        lua_getfield(L, 1, "module");
        switch (lua_type(L, -1)) {
        case LUA_TSTRING:
            module = tostringview(L, -1);
            break;
        case LUA_TNIL:
            break;
        default:
            push(L, std::errc::invalid_argument, "arg", "module");
            return lua_error(L);
        }
        [[maybe_unused]] bool host_type_already_defined = false;
        lua_getfield(L, 1, "inherit_context");
        if (lua_type(L, -1) == LUA_TBOOLEAN) {
            inherit_ctx = lua_toboolean(L, -1);
            host_type_already_defined = true;
        }
        lua_getfield(L, 1, "new_master");
        if (lua_type(L, -1) == LUA_TBOOLEAN) {
            new_master = lua_toboolean(L, -1);
            if (new_master && !vm_ctx.is_master()) {
                push(L, std::errc::operation_not_permitted);
                return lua_error(L);
            }

            host_type_already_defined = true;
        }
#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL >= 1
        lua_getfield(L, 1, "concurrency_hint");
        if (lua_type(L, -1) == LUA_TNUMBER) {
            int user_concurrency_hint = lua_tointeger(L, -1);
            if (user_concurrency_hint == 1)
                concurrency_hint = 1;
        }
#endif
        lua_getfield(L, 1, "subprocess");
        if (lua_type(L, -1) == LUA_TTABLE) {
#if BOOST_OS_UNIX
            if (host_type_already_defined) {
                push(L, std::errc::invalid_argument, "arg", 1);
                return lua_error(L);
            }
            host_type_already_defined = true;
            run_in_subprocess = true;

            lua_getfield(L, -1, "newns_uts");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/newns_uts");
                return lua_error(L);
            case LUA_TBOOLEAN:
# if BOOST_OS_LINUX
                if (lua_toboolean(L, -1)) {
                    request.clone_flags |= CLONE_NEWUTS;
                }
# else // BOOST_OS_LINUX
                push(L, std::errc::not_supported);
                return lua_error(L);
# endif // BOOST_OS_LINUX
                [[fallthrough]];
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "newns_ipc");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/newns_ipc");
                return lua_error(L);
            case LUA_TBOOLEAN:
# if BOOST_OS_LINUX
                if (lua_toboolean(L, -1)) {
                    request.clone_flags |= CLONE_NEWIPC;
                }
# else // BOOST_OS_LINUX
                push(L, std::errc::not_supported);
                return lua_error(L);
# endif // BOOST_OS_LINUX
                [[fallthrough]];
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "newns_pid");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/newns_pid");
                return lua_error(L);
            case LUA_TBOOLEAN:
# if BOOST_OS_LINUX
                if (lua_toboolean(L, -1)) {
                    request.clone_flags |= CLONE_NEWPID;
                }
# else // BOOST_OS_LINUX
                push(L, std::errc::not_supported);
                return lua_error(L);
# endif // BOOST_OS_LINUX
                [[fallthrough]];
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "newns_user");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/newns_user");
                return lua_error(L);
            case LUA_TBOOLEAN:
# if BOOST_OS_LINUX
                if (lua_toboolean(L, -1)) {
                    request.clone_flags |= CLONE_NEWUSER;
                }
# else // BOOST_OS_LINUX
                push(L, std::errc::not_supported);
                return lua_error(L);
# endif // BOOST_OS_LINUX
                [[fallthrough]];
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "newns_net");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/newns_net");
                return lua_error(L);
            case LUA_TBOOLEAN:
# if BOOST_OS_LINUX
                if (lua_toboolean(L, -1)) {
                    request.clone_flags |= CLONE_NEWNET;
                }
# else // BOOST_OS_LINUX
                push(L, std::errc::not_supported);
                return lua_error(L);
# endif // BOOST_OS_LINUX
                [[fallthrough]];
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "newns_mount");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/newns_mount");
                return lua_error(L);
            case LUA_TBOOLEAN:
# if BOOST_OS_LINUX
                if (lua_toboolean(L, -1)) {
                    request.clone_flags |= CLONE_NEWNS;
                }
# else // BOOST_OS_LINUX
                push(L, std::errc::not_supported);
                return lua_error(L);
# endif // BOOST_OS_LINUX
                [[fallthrough]];
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "stdin");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/stdin");
                return lua_error(L);
            case LUA_TSTRING:
                if (tostringview(L) != "share") {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stdin");
                    return lua_error(L);
                }
                proc_stdin = STDIN_FILENO;
                lua_pop(L, 1);
                break;
            case LUA_TUSERDATA: {
                auto handle = static_cast<file_descriptor_handle*>(
                    lua_touserdata(L, -1));
                if (!lua_getmetatable(L, -1)) {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stdin");
                    return lua_error(L);
                }
                rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
                if (!lua_rawequal(L, -1, -2)) {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stdin");
                    return lua_error(L);
                }
                if (*handle == INVALID_FILE_DESCRIPTOR) {
                    push(L, std::errc::device_or_resource_busy,
                         "arg", "subprocess/stdin");
                    return lua_error(L);
                }
                proc_stdin = *handle;
                lua_pop(L, 3);
                break;
            }
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "stdout");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/stdout");
                return lua_error(L);
            case LUA_TSTRING:
                if (tostringview(L) != "share") {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stdout");
                    return lua_error(L);
                }
                proc_stdout = STDOUT_FILENO;
                lua_pop(L, 1);
                break;
            case LUA_TUSERDATA: {
                auto handle = static_cast<file_descriptor_handle*>(
                    lua_touserdata(L, -1));
                if (!lua_getmetatable(L, -1)) {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stdout");
                    return lua_error(L);
                }
                rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
                if (!lua_rawequal(L, -1, -2)) {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stdout");
                    return lua_error(L);
                }
                if (*handle == INVALID_FILE_DESCRIPTOR) {
                    push(L, std::errc::device_or_resource_busy,
                         "arg", "subprocess/stdout");
                    return lua_error(L);
                }
                proc_stdout = *handle;
                lua_pop(L, 3);
                break;
            }
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "stderr");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/stderr");
                return lua_error(L);
            case LUA_TSTRING:
                if (tostringview(L) != "share") {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stderr");
                    return lua_error(L);
                }
                proc_stderr = STDERR_FILENO;
                lua_pop(L, 1);
                break;
            case LUA_TUSERDATA: {
                auto handle = static_cast<file_descriptor_handle*>(
                    lua_touserdata(L, -1));
                if (!lua_getmetatable(L, -1)) {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stderr");
                    return lua_error(L);
                }
                rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
                if (!lua_rawequal(L, -1, -2)) {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/stderr");
                    return lua_error(L);
                }
                if (*handle == INVALID_FILE_DESCRIPTOR) {
                    push(L, std::errc::device_or_resource_busy,
                         "arg", "subprocess/stderr");
                    return lua_error(L);
                }
                proc_stderr = *handle;
                lua_pop(L, 3);
                break;
            }
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "environment");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/environment");
                return lua_error(L);
            case LUA_TTABLE:
                lua_pushnil(L);
                while (lua_next(L, -2) != 0) {
                    if (
                        lua_type(L, -2) != LUA_TSTRING ||
                        lua_type(L, -1) != LUA_TSTRING
                    ) {
                        push(L, std::errc::invalid_argument,
                             "arg", "subprocess/environment");
                        return lua_error(L);
                    }

                    newenv.emplace(tostringview(L, -2), tostringview(L));
                    lua_pop(L, 1);
                }

                [[fallthrough]];
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }

            lua_getfield(L, -1, "init");
            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument,
                     "arg", "subprocess/init");
                return lua_error(L);
            case LUA_TTABLE:
                request.has_lua_hook = 1;

                lua_getfield(L, -1, "arg");
                switch (lua_type(L, -1)) {
                default:
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/init/arg");
                    return lua_error(L);
                case LUA_TUSERDATA: {
                    auto handle = static_cast<file_descriptor_handle*>(
                        lua_touserdata(L, -1));
                    if (!lua_getmetatable(L, -1)) {
                        push(L, std::errc::invalid_argument,
                             "arg", "subprocess/init/arg");
                        return lua_error(L);
                    }
                    rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
                    if (!lua_rawequal(L, -1, -2)) {
                        push(L, std::errc::invalid_argument,
                             "arg", "subprocess/init/arg");
                        return lua_error(L);
                    }
                    if (*handle == INVALID_FILE_DESCRIPTOR) {
                        push(L, std::errc::device_or_resource_busy,
                             "arg", "subprocess/init/arg");
                        return lua_error(L);
                    }
                    lua_hook_fd = *handle;
                    lua_pop(L, 3);
                    break;
                }
                case LUA_TNIL:
                    lua_pop(L, 1);
                    break;
                }

                lua_getfield(L, -1, "script");
                if (lua_type(L, -1) != LUA_TSTRING) {
                    push(L, std::errc::invalid_argument,
                         "arg", "subprocess/init/script");
                    return lua_error(L);
                }
                lua_hook.emplace(tostringview(L));

                lua_pop(L, 2);
                break;
            case LUA_TNIL:
                lua_pop(L, 1);
                break;
            }
#else // BOOST_OS_UNIX
            push(L, std::errc::not_supported);
            return lua_error(L);
#endif // BOOST_OS_UNIX
        }
    }

#if BOOST_OS_UNIX
    if (run_in_subprocess) {
        if (vm_ctx.appctx.ipc_actor_service_sockfd == -1) {
            push(L, std::errc::no_child_process);
            return lua_error(L);
        }

        std::string body;
        {
            constexpr unsigned int aflags = boost::archive::no_header |
                boost::archive::no_codecvt |
                boost::archive::no_xml_tag_checking;
            std::ostringstream os;
            boost::archive::binary_oarchive oa{os, aflags};
            oa << concurrency_hint << std::string{module} << newenv;
            body = os.str();
        }

        switch (proc_stdin) {
        case -1:
            request.stdin_action = ipc_actor_start_vm_request::CLOSE_FD;
            break;
        case STDIN_FILENO:
            request.stdin_action = ipc_actor_start_vm_request::SHARE_PARENT;
            break;
        default:
            request.stdin_action = ipc_actor_start_vm_request::USE_PIPE;
        }

        switch (proc_stdout) {
        case -1:
            request.stdout_action = ipc_actor_start_vm_request::CLOSE_FD;
            break;
        case STDOUT_FILENO:
            request.stdout_action = ipc_actor_start_vm_request::SHARE_PARENT;
            break;
        default:
            request.stdout_action = ipc_actor_start_vm_request::USE_PIPE;
        }

        switch (proc_stderr) {
        case -1:
            request.stderr_action = ipc_actor_start_vm_request::CLOSE_FD;
            break;
        case STDERR_FILENO:
            request.stderr_action = ipc_actor_start_vm_request::SHARE_PARENT;
            request.stderr_has_color = emilua::stdout_has_color;
            break;
        default:
            request.stderr_action = ipc_actor_start_vm_request::USE_PIPE;
        }

        if (body.size() > EMILUA_CONFIG_IPC_ACTOR_MESSAGE_SIZE) {
            push(L, std::errc::message_size);
            return lua_error(L);
        }

        int channel[2];
        int res = socketpair(AF_UNIX, SOCK_SEQPACKET, 0, channel);
        if (res != 0) {
            push(L, std::error_code{errno, std::system_category()});
            return lua_error(L);
        }

        struct msghdr msg;
        std::memset(&msg, 0, sizeof(msg));

        struct iovec iov;
        iov.iov_base = &request;
        iov.iov_len = sizeof(request);
        msg.msg_iov = &iov;
        msg.msg_iovlen = 1;

        union {
            struct cmsghdr align;
            char buf[CMSG_SPACE(sizeof(int) * 4)];
        } cmsgu;
        msg.msg_control = cmsgu.buf;
        msg.msg_controllen = sizeof(cmsgu.buf);

        {
            struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
            cmsg->cmsg_level = SOL_SOCKET;
            cmsg->cmsg_type = SCM_RIGHTS;

            char* begin = (char*)CMSG_DATA(cmsg);
            char* it = begin;
            std::memcpy(it, &channel[0], sizeof(int));
            it += sizeof(int);

            if (request.stdin_action == ipc_actor_start_vm_request::USE_PIPE) {
                std::memcpy(it, &proc_stdin, sizeof(int));
                it += sizeof(int);
            }

            if (request.stdout_action == ipc_actor_start_vm_request::USE_PIPE) {
                std::memcpy(it, &proc_stdout, sizeof(int));
                it += sizeof(int);
            }

            if (request.stderr_action == ipc_actor_start_vm_request::USE_PIPE) {
                std::memcpy(it, &proc_stderr, sizeof(int));
                it += sizeof(int);
            }

            auto nfds = (it - begin) / sizeof(int);
            cmsg->cmsg_len = CMSG_LEN(sizeof(int) * nfds);
            msg.msg_controllen = CMSG_SPACE(sizeof(int) * nfds);
        }

        auto nwritten = sendmsg(vm_ctx.appctx.ipc_actor_service_sockfd,
                                &msg, MSG_NOSIGNAL);
        int send_errno = errno;
        close(channel[0]);
        BOOST_SCOPE_EXIT_ALL(&) {
            if (channel[1] != -1) close(channel[1]);
        };
        if (nwritten == -1) {
            std::error_code ec{send_errno, std::system_category()};
            push(L, ec);
            return lua_error(L);
        }

        ipc_actor_start_vm_reply reply;

        std::memset(&msg, 0, sizeof(msg));
        iov.iov_base = &reply;
        iov.iov_len = sizeof(reply);
        msg.msg_iov = &iov;
        msg.msg_iovlen = 1;

        msg.msg_control = cmsgu.buf;
        msg.msg_controllen = CMSG_SPACE(sizeof(int));

        auto nread = recvmsg(channel[1], &msg, /*flags=*/0);
        if (nread == -1) {
            std::error_code ec{errno, std::system_category()};
            push(L, ec);
            return lua_error(L);
        }

        shutdown(channel[1], SHUT_RD);

        int pidfd = -1;
        BOOST_SCOPE_EXIT_ALL(&) {
            if (pidfd != -1) close(pidfd);
        };

        for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg) ; cmsg != NULL ;
             cmsg = CMSG_NXTHDR(&msg, cmsg)) {
            if (cmsg->cmsg_level != SOL_SOCKET ||
                cmsg->cmsg_type != SCM_RIGHTS) {
                continue;
            }

            assert(cmsg->cmsg_len - CMSG_LEN(0) <= sizeof(int));
            std::memcpy(&pidfd, CMSG_DATA(cmsg), cmsg->cmsg_len - CMSG_LEN(0));
            break;
        }

        if (nread == 0) {
            push(L, make_error_code(asio::error::eof));
            return lua_error(L);
        }
        assert(nread == sizeof(reply));

        if (reply.error != 0) {
            std::error_code ec{reply.error, std::system_category()};
            push(L, ec);
            return lua_error(L);
        }

        if (pidfd == -1) {
            push(L, std::errc::too_many_files_open);
            return lua_error(L);
        }

        if (send(channel[1], body.data(), body.size(), MSG_NOSIGNAL) == -1) {
            std::error_code ec{errno, std::system_category()};
            push(L, ec);
            return lua_error(L);
        }

        if (lua_hook) {
            std::memset(&msg, 0, sizeof(msg));
            iov.iov_base = lua_hook->data();
            iov.iov_len = lua_hook->size();
            msg.msg_iov = &iov;
            msg.msg_iovlen = 1;

            if (lua_hook_fd != -1) {
                msg.msg_control = cmsgu.buf;
                msg.msg_controllen = CMSG_SPACE(sizeof(int));
                struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
                cmsg->cmsg_level = SOL_SOCKET;
                cmsg->cmsg_type = SCM_RIGHTS;
                cmsg->cmsg_len = CMSG_LEN(sizeof(int));
                std::memcpy(CMSG_DATA(cmsg), &lua_hook_fd, sizeof(int));
            }

            if (sendmsg(channel[1], &msg, MSG_NOSIGNAL) == -1) {
                std::error_code ec{errno, std::system_category()};
                push(L, ec);
                return lua_error(L);
            }
        }

#if BOOST_OS_LINUX
        auto reaper = new ipc_actor_reaper{pidfd, reply.childpid};
#else
        auto reaper = new ipc_actor_reaper{pidfd};
#endif // BOOST_OS_LINUX
        vm_ctx.pending_operations.push_back(*reaper);
        pidfd = -1;

        auto ch = static_cast<ipc_actor_address*>(
            lua_newuserdata(L, sizeof(ipc_actor_address)));
        rawgetp(L, LUA_REGISTRYINDEX, &ipc_actor_chan_mt_key);
        setmetatable(L, -2);
        new (ch) ipc_actor_address{vm_ctx.strand().context()};

        asio::local::datagram_protocol protocol;
        boost::system::error_code ignored_ec;
        ch->dest.assign(protocol, channel[1], ignored_ec);
        assert(!ignored_ec);
        channel[1] = -1;

        ch->reaper = reaper;
        return 1;
    }
#endif // BOOST_OS_UNIX

    fs::path module_path;
    bool is_leaf = vm_ctx.import_tree[importer_path].is_leaf;

    /*!re2c
    re2c:define:YYCTYPE = char;
    re2c:yyfill:enable = 0;
    re2c:indent:string = "    ";
    */
    /*!include:re2c "emilua/modules.re" */
    if (module == ".") {
        module_path = importer_path;
    } else if (module.starts_with(".")) {
        if (module.starts_with("./"))
            module.remove_prefix(2);

        const char* YYCURSOR = module.data();
        const char* YYMARKER;
        const char* begin;
        int nparents = 0;
    loop_parse_dot:
        begin = YYCURSOR;
        %{
        * {
            push(L, errc::invalid_module_name, "module", module);
            return lua_error(L);
        }
        {emilua_parentpat} {
            ++nparents;
            goto loop_parse_dot;
        }
        {emilua_modnamepat} {
            if (*YYCURSOR != '\0') {
                push(L, errc::invalid_module_name, "module", module);
                return lua_error(L);
            }
            goto end_parse_dot;
        }
        %}
    end_parse_dot:

        module = std::string_view(begin, YYCURSOR - begin);

        if (nparents == 0 && is_leaf) {
            push(L, errc::leaf_cannot_import_child);
            return lua_error(L);
        }

        module_path = importer_path.parent_path();
        for (int i = (is_leaf ? 1u : 0u) ; i != nparents ; ++i) {
            if (!module_path.has_parent_path() || module_path == import_root) {
                push(L, errc::root_cannot_import_parent);
                return lua_error(L);
            }

            module_path = module_path.parent_path();
        }
        try {
            std::shared_lock modules_cache_registry_rlock{
                vm_ctx.appctx.modules_cache_registry_mtx};

            if (vm_ctx.appctx.modules_cache_registry.contains(
                module_path / (std::string{module} + ".lua")
            )) {
                module_path /= std::string{module} + ".lua";
            } else if (vm_ctx.appctx.modules_cache_registry.contains(
                module_path / module / "init.lua"
            )) {
                module_path /= module;
                module_path /= "init.lua";
            } else if (
                fs::exists(module_path / (std::string{module} + ".lua"))
            ) {
                module_path /= std::string{module} + ".lua";
            } else if (fs::exists(module_path / module / "init.lua")) {
                module_path /= module;
                module_path /= "init.lua";
            } else {
                throw std::system_error{errc::module_not_found};
            }
        } catch (const std::system_error& e) {
            push(L, e.code(), "module", module);
            return lua_error(L);
        }
    } else if (module.starts_with("/")) {
        const char* YYCURSOR = module.data();
        const char* YYMARKER;
        boost::ignore_unused(YYMARKER);
        const char* begin;
    loop_parse_slash:
        begin = YYCURSOR;
        %{
        * {
            push(L, errc::invalid_module_name, "module", module);
            return lua_error(L);
        }
        {emilua_modseppat}{emilua_modnamepat} {
            std::string_view component(begin + 1, YYCURSOR - begin - 1);
            if (*YYCURSOR == '\0') {
                module = component;
                goto end_parse_slash;
            } else {
                module_path /= component;
                goto loop_parse_slash;
            }
        }
        %}
    end_parse_slash:

        module_path = import_root;
        try {
            std::shared_lock modules_cache_registry_rlock{
                vm_ctx.appctx.modules_cache_registry_mtx};

            if (vm_ctx.appctx.modules_cache_registry.contains(
                module_path / (std::string{module} + ".lua")
            )) {
                module_path /= std::string{module} + ".lua";
            } else if (vm_ctx.appctx.modules_cache_registry.contains(
                module_path / module / "init.lua"
            )) {
                module_path /= module;
                module_path /= "init.lua";
            } else if (
                fs::exists(module_path / (std::string{module} + ".lua"))
            ) {
                module_path /= std::string{module} + ".lua";
            } else if (fs::exists(module_path / module / "init.lua")) {
                module_path /= module;
                module_path /= "init.lua";
            } else {
                throw std::system_error{errc::module_not_found};
            }
        } catch (const std::system_error& e) {
            push(L, e.code(), "module", module);
            return lua_error(L);
        }
    } else {
        push(L, errc::invalid_module_name);
        return lua_error(L);
    }

#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL >= 1
    // * `work_guard` must live until we call strand.post()
    // * `work_guard` must be init'ed before we even spawn the thread to call
    //   ioctx.run()
    std::shared_ptr<asio::io_context> new_ioctx = nullptr;
    std::optional<asio::executor_work_guard<asio::io_context::executor_type>>
        work_guard = std::nullopt;

    if (!inherit_ctx) {
        new_ioctx = std::make_shared<asio::io_context>(concurrency_hint);
        asio::make_service<properties_service>(*new_ioctx, concurrency_hint);
        work_guard.emplace(new_ioctx->get_executor());

        {
            std::unique_lock<std::mutex> lk{
                vm_ctx.appctx.extra_threads_count_mtx};
            // must happen before we return from this function (i.e. before the
            // control returns to the runtime)
            ++vm_ctx.appctx.extra_threads_count;
        }
        std::thread{[&appctx=vm_ctx.appctx,new_ioctx]() mutable {
            new_ioctx->run();
            new_ioctx.reset();

            std::unique_lock<std::mutex> lk{appctx.extra_threads_count_mtx};
            --appctx.extra_threads_count;
            if (appctx.extra_threads_count == 0) {
                std::notify_all_at_thread_exit(
                    appctx.extra_threads_count_empty_cond, std::move(lk));
            } else {
                std::notify_all_at_thread_exit(
                    appctx.extra_threads_count_dummy_cond, std::move(lk));
            }
        }}.detach();
    }
#else
    if (!inherit_ctx) {
        push(L, std::errc::not_supported);
        return lua_error(L);
    }
#endif

    try {
#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL >= 1
        auto new_vm_ctx = emilua::make_vm(
            new_ioctx ? *new_ioctx : vm_ctx.strand().context(),
            vm_ctx.appctx, emilua::ContextType::worker, module_path,
            import_root);
        new_vm_ctx->ioctxref = new_ioctx;
#else
        auto new_vm_ctx = emilua::make_vm(
            vm_ctx.strand().context(), vm_ctx.appctx,
            emilua::ContextType::worker, module_path, import_root);
#endif

        if (new_master) {
            vm_ctx.appctx.master_vm = new_vm_ctx;
        }

        auto buf = static_cast<actor_address*>(
            lua_newuserdata(L, sizeof(actor_address))
        );
        rawgetp(L, LUA_REGISTRYINDEX, &tx_chan_mt_key);
        setmetatable(L, -2);
        new (buf) actor_address{*new_vm_ctx};

        new_vm_ctx->strand().post([new_vm_ctx]() {
            new_vm_ctx->fiber_resume(
                new_vm_ctx->L(),
                hana::make_set(vm_context::options::skip_clear_interrupter));
        }, std::allocator<void>{});

        return 1;
    } catch (const std::bad_alloc&) {
        push(L, std::errc::not_enough_memory);
        return lua_error(L);
    } catch (const std::system_error& e) {
        push(L, e.code());
        return lua_error(L);
    } catch (const std::exception& e) {
        lua_pushstring(L, e.what());
        return lua_error(L);
    }
}

static int spawn_context_threads(lua_State* L)
{
#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL < 2
    push(L, std::errc::function_not_supported);
    return lua_error(L);
#else
    luaL_checktype(L, 1, LUA_TNUMBER);

    auto& vm_ctx = get_vm_context(L);
    auto nthrds = lua_tointeger(L, 1);

    int concurrency_hint = asio::use_service<properties_service>(
        vm_ctx.strand().context()).concurrency_hint;
    if (concurrency_hint == 1) {
        push(L, std::errc::not_supported);
        return lua_error(L);
    }

    if (nthrds <= 0)
        return 0;

    {
        std::unique_lock<std::mutex> lk{vm_ctx.appctx.extra_threads_count_mtx};
        // must happen before we return from this function (i.e. before the
        // control returns to the runtime)
        vm_ctx.appctx.extra_threads_count += nthrds;
    }
    for (;nthrds > 0 ; --nthrds) {
        std::thread{
            [
                &appctx=vm_ctx.appctx,
                &ioctx=vm_ctx.strand().context(),
                guard=vm_ctx.ioctxref.lock()
            ]() mutable {
                ioctx.run(); //< doesn't need a work guard
                guard.reset();

                std::unique_lock<std::mutex> lk{appctx.extra_threads_count_mtx};
                --appctx.extra_threads_count;
                if (appctx.extra_threads_count == 0) {
                    std::notify_all_at_thread_exit(
                        appctx.extra_threads_count_empty_cond, std::move(lk));
                } else {
                    std::notify_all_at_thread_exit(
                        appctx.extra_threads_count_dummy_cond, std::move(lk));
                }
            }
        }.detach();
    }
    return 0;
#endif
}

static int tx_chan_mt_eq(lua_State* L)
{
    auto is_same = [](const std::weak_ptr<vm_context>& a,
                      const std::weak_ptr<vm_context>& b) {
        return !a.owner_before(b) && !b.owner_before(a);
    };

    const auto& a = *static_cast<actor_address*>(lua_touserdata(L, 1));
    const auto& b = *static_cast<actor_address*>(lua_touserdata(L, 2));
    lua_pushboolean(L, is_same(a.dest, b.dest) ? 1 : 0);
    return 1;
}

static int tx_chan_mt_index(lua_State* L)
{
    auto key = tostringview(L, 2);
    if (key == "send") {
        rawgetp(L, LUA_REGISTRYINDEX, &chan_send_key);
        return 1;
    } else if (key == "close") {
        lua_pushcfunction(L, tx_chan_close);
        return 1;
    } else {
        push(L, errc::bad_index, "index", 2);
        return lua_error(L);
    }
}

static int closed_tx_chan_mt_index(lua_State* L)
{
    auto key = tostringview(L, 2);
    if (key == "send") {
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                push(L, errc::channel_closed);
                return lua_error(L);
            }
        );
        return 1;
    } else if (key == "close") {
        lua_pushcfunction(L, [](lua_State*) -> int { return 0; });
        return 1;
    } else {
        push(L, errc::bad_index, "index", 2);
        return lua_error(L);
    }
}

static int inbox_mt_index(lua_State* L)
{
    auto key = tostringview(L, 2);
    if (key == "receive") {
        rawgetp(L, LUA_REGISTRYINDEX, &chan_receive_key);
        return 1;
    } else if (key == "close") {
        lua_pushcfunction(L, inbox_close);
        return 1;
    } else {
        push(L, errc::bad_index, "index", 2);
        return lua_error(L);
    }
}

#if BOOST_OS_UNIX
static int ipc_actor_chan_send(lua_State* L)
{
    lua_settop(L, 2);

    auto& vm_ctx = get_vm_context(L);
    EMILUA_CHECK_SUSPEND_ALLOWED(vm_ctx, L);

    auto channel = static_cast<ipc_actor_address*>(lua_touserdata(L, 1));
    if (!channel || !lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &ipc_actor_chan_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    if (!channel->dest.is_open()) {
        push(L, errc::channel_closed);
        return lua_error(L);
    }

    auto cancel_slot = set_default_interrupter(L, vm_ctx);

    auto op = std::make_shared<ipc_actor_send_op>(
        vm_ctx, std::move(cancel_slot), channel->dest);
    using descriptors_size_type = decltype(op->descriptors_size);
    bool op_started = false;
    BOOST_SCOPE_EXIT_ALL(&) {
        if (op_started)
            return;

        for (descriptors_size_type i = 0 ; i != op->descriptors_size ; ++i) {
            if (op->descriptors[i].reference)
                continue;

            int res = close(op->descriptors[i].value);
            boost::ignore_unused(res);
        }
    };

    unsigned char* strit = op->message.strbuf;
    switch (lua_type(L, 2)) {
    case LUA_TNIL:
    case LUA_TFUNCTION:
    case LUA_TTHREAD:
    case LUA_TLIGHTUSERDATA:
        push(L, std::errc::invalid_argument, "arg", 2);
        return lua_error(L);
    case LUA_TBOOLEAN:
        op->message.members[0].as_int = EXPONENT_MASK | ipc_actor_message::nil;
        op->message.members[1].as_int = EXPONENT_MASK;
        op->message.members[1].as_int |=
            lua_toboolean(L, 2) ?
            ipc_actor_message::boolean_true :
            ipc_actor_message::boolean_false;
        op->message_size = sizeof(op->message.members[0]) * 2;
        break;
    case LUA_TNUMBER:
        op->message.members[0].as_int = EXPONENT_MASK |
            ipc_actor_message::nil;
        op->message.members[1].as_double = lua_tonumber(L, 2);
        assert(!is_snan(op->message.members[1].as_int));
        op->message_size = sizeof(op->message.members[0]) * 2;
        break;
    case LUA_TSTRING: {
        auto v = tostringview(L, 2);
        if (v.size() > 255) {
            push(L, std::errc::invalid_argument, "arg", 2);
            return lua_error(L);
        }
        op->message.members[0].as_int = EXPONENT_MASK | ipc_actor_message::nil;
        op->message.members[1].as_int = EXPONENT_MASK |
            ipc_actor_message::string;
        *strit++ = v.size();
        std::memcpy(strit, v.data(), v.size());
        strit += v.size();

        // avoid leaking any non-initialized data on our stack/memory to remote
        // processes
        std::memset(
            &op->message.members[2], 0,
            sizeof(op->message.members[0]) *
            (EMILUA_CONFIG_IPC_ACTOR_MESSAGE_MAX_MEMBERS_NUMBER - 2));

        op->message_size =
            strit - reinterpret_cast<unsigned char*>(&op->message);
        break;
    }
    case LUA_TUSERDATA:
        if (!lua_getmetatable(L, 2)) {
            push(L, std::errc::invalid_argument, "arg", 2);
            return lua_error(L);
        }
        rawgetp(L, LUA_REGISTRYINDEX, &tx_chan_mt_key);
        if (lua_rawequal(L, -1, -2)) {
            int channel[2];
            int res = socketpair(AF_UNIX, SOCK_SEQPACKET, 0, channel);
            if (res != 0) {
                push(L, std::error_code{errno, std::system_category()});
                return lua_error(L);
            }
            shutdown(channel[0], SHUT_WR);
            shutdown(channel[1], SHUT_RD);

            {
                const auto& msg = *static_cast<const actor_address*>(
                    lua_touserdata(L, 2));

                auto inboxfd = channel[0];
                auto dest = msg.dest.lock();
                if (dest) {
                    ++dest->inbox.nsenders;
                    dest->strand().post([dest,inboxfd]() {
                        if (!dest->valid()) {
                            int res = close(inboxfd);
                            boost::ignore_unused(res);
                            return;
                        }
                        auto inbox_service = new ipc_actor_inbox_service{
                            dest->strand().context(), inboxfd};
                        dest->pending_operations.push_back(*inbox_service);
                        if (dest->inbox.recv_fiber)
                            inbox_service->async_enqueue(*dest);
                    }, std::allocator<void>{});
                } else {
                    int res = close(inboxfd);
                    boost::ignore_unused(res);
                }
            }

            op->message.members[0].as_int = EXPONENT_MASK |
                ipc_actor_message::nil;
            op->message.members[1].as_int = EXPONENT_MASK |
                ipc_actor_message::actor_address;
            op->message_size = sizeof(op->message.members[0]) * 2;
            op->descriptors[0].value = channel[1];
            op->descriptors_size = 1;
            break;
        }
        rawgetp(L, LUA_REGISTRYINDEX, &inbox_mt_key);
        if (lua_rawequal(L, -1, -3)) {
            int channel[2];
            int res = socketpair(AF_UNIX, SOCK_SEQPACKET, 0, channel);
            if (res != 0) {
                push(L, std::error_code{errno, std::system_category()});
                return lua_error(L);
            }
            shutdown(channel[0], SHUT_WR);
            shutdown(channel[1], SHUT_RD);

            ++vm_ctx.inbox.nsenders;
            auto inbox_service = new ipc_actor_inbox_service{
                vm_ctx.strand().context(), channel[0]};
            vm_ctx.pending_operations.push_back(*inbox_service);

            op->message.members[0].as_int = EXPONENT_MASK |
                ipc_actor_message::nil;
            op->message.members[1].as_int = EXPONENT_MASK |
                ipc_actor_message::actor_address;
            op->message_size = sizeof(op->message.members[0]) * 2;
            op->descriptors[0].value = channel[1];
            op->descriptors_size = 1;
            break;
        }
        rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
        if (lua_rawequal(L, -1, -4)) {
            auto msg = static_cast<file_descriptor_handle*>(
                lua_touserdata(L, 2));
            if (*msg == INVALID_FILE_DESCRIPTOR) {
                push(L, std::errc::device_or_resource_busy);
                return lua_error(L);
            }

            op->message.members[0].as_int = EXPONENT_MASK |
                ipc_actor_message::nil;
            op->message.members[1].as_int = EXPONENT_MASK |
                ipc_actor_message::file_descriptor;
            op->message_size = sizeof(op->message.members[0]) * 2;
            op->descriptors[0].reference = msg;
            op->descriptors_size = 1;
            break;
        }
        push(L, std::errc::invalid_argument, "arg", 2);
        return lua_error(L);
    case LUA_TTABLE: {
        if (lua_getmetatable(L, 2)) {
            push(L, std::errc::invalid_argument, "arg", 2);
            return lua_error(L);
        }

        int nf = 0;
        lua_pushnil(L);
        while (lua_next(L, 2) != 0) {
            if (lua_type(L, -2) != LUA_TSTRING) {
                lua_pop(L, 1);
                continue;
            }

            if (nf == EMILUA_CONFIG_IPC_ACTOR_MESSAGE_MAX_MEMBERS_NUMBER) {
                push(L, std::errc::invalid_argument, "arg", 2);
                return lua_error(L);
            }

            auto key = tostringview(L, -2);
            if (key.size() > 255) {
                push(L, std::errc::invalid_argument, "arg", 2);
                return lua_error(L);
            }
            *strit++ = key.size();
            std::memcpy(strit, key.data(), key.size());
            strit += key.size();

            switch (lua_type(L, -1)) {
            default:
                push(L, std::errc::invalid_argument, "arg", 2);
                return lua_error(L);
            case LUA_TBOOLEAN:
                op->message.members[nf].as_int = EXPONENT_MASK;
                op->message.members[nf].as_int |=
                    lua_toboolean(L, -1) ?
                    ipc_actor_message::boolean_true :
                    ipc_actor_message::boolean_false;
                break;
            case LUA_TNUMBER:
                op->message.members[nf].as_double = lua_tonumber(L, -1);
                assert(!is_snan(op->message.members[nf].as_int));
                break;
            case LUA_TSTRING: {
                auto v = tostringview(L, -1);
                if (v.size() > 255) {
                    push(L, std::errc::invalid_argument, "arg", 2);
                    return lua_error(L);
                }
                op->message.members[nf].as_int = EXPONENT_MASK |
                    ipc_actor_message::string;
                *strit++ = v.size();
                std::memcpy(strit, v.data(), v.size());
                strit += v.size();
                break;
            }
            case LUA_TUSERDATA:
                if (!lua_getmetatable(L, -1)) {
                    push(L, std::errc::invalid_argument, "arg", 2);
                    return lua_error(L);
                }
                rawgetp(L, LUA_REGISTRYINDEX, &tx_chan_mt_key);
                if (lua_rawequal(L, -1, -2)) {
                    lua_pop(L, 2);
                    int channel[2];
                    int res = socketpair(AF_UNIX, SOCK_SEQPACKET, 0, channel);
                    if (res != 0) {
                        push(L, std::error_code{errno, std::system_category()});
                        return lua_error(L);
                    }
                    shutdown(channel[0], SHUT_WR);
                    shutdown(channel[1], SHUT_RD);

                    {
                        const auto& msg = *static_cast<const actor_address*>(
                            lua_touserdata(L, -1));

                        auto inboxfd = channel[0];
                        auto dest = msg.dest.lock();
                        if (dest) {
                            ++dest->inbox.nsenders;
                            dest->strand().post([dest,inboxfd]() {
                                if (!dest->valid()) {
                                    int res = close(inboxfd);
                                    boost::ignore_unused(res);
                                    return;
                                }
                                auto inbox_service =
                                    new ipc_actor_inbox_service{
                                        dest->strand().context(), inboxfd};
                                dest->pending_operations.push_back(
                                    *inbox_service);
                                if (dest->inbox.recv_fiber)
                                    inbox_service->async_enqueue(*dest);
                            }, std::allocator<void>{});
                        } else {
                            int res = close(inboxfd);
                            boost::ignore_unused(res);
                        }
                    }

                    op->message.members[nf].as_int = EXPONENT_MASK |
                        ipc_actor_message::actor_address;
                    op->descriptors[op->descriptors_size++].value = channel[1];
                    break;
                }
                rawgetp(L, LUA_REGISTRYINDEX, &inbox_mt_key);
                if (lua_rawequal(L, -1, -3)) {
                    lua_pop(L, 3);
                    int channel[2];
                    int res = socketpair(AF_UNIX, SOCK_SEQPACKET, 0, channel);
                    if (res != 0) {
                        push(L, std::error_code{errno, std::system_category()});
                        return lua_error(L);
                    }
                    shutdown(channel[0], SHUT_WR);
                    shutdown(channel[1], SHUT_RD);

                    ++vm_ctx.inbox.nsenders;
                    auto inbox_service = new ipc_actor_inbox_service{
                        vm_ctx.strand().context(), channel[0]};
                    vm_ctx.pending_operations.push_back(*inbox_service);

                    op->message.members[nf].as_int = EXPONENT_MASK |
                        ipc_actor_message::actor_address;
                    op->descriptors[op->descriptors_size++].value = channel[1];
                    break;
                }
                rawgetp(L, LUA_REGISTRYINDEX, &file_descriptor_mt_key);
                if (lua_rawequal(L, -1, -4)) {
                    lua_pop(L, 4);
                    auto msg = static_cast<file_descriptor_handle*>(
                        lua_touserdata(L, -1));
                    if (*msg == INVALID_FILE_DESCRIPTOR) {
                        push(L, std::errc::device_or_resource_busy);
                        return lua_error(L);
                    }

                    op->message.members[nf].as_int = EXPONENT_MASK |
                        ipc_actor_message::file_descriptor;
                    op->descriptors[op->descriptors_size++].reference = msg;
                    break;
                }
                push(L, std::errc::invalid_argument, "arg", 2);
                return lua_error(L);
            }
            ++nf;
            lua_pop(L, 1);
        }

        if (nf == 0) {
            push(L, std::errc::invalid_argument, "arg", 2);
            return lua_error(L);
        }

        for (
            int i = nf ;
            i != EMILUA_CONFIG_IPC_ACTOR_MESSAGE_MAX_MEMBERS_NUMBER ; ++i
        ) {
            // Per protocol, only the first nil value need to be marked. However
            // we want to avoid leaking any non-initialized data on our
            // stack/memory to remote processes.
            op->message.members[i].as_int = EXPONENT_MASK |
                ipc_actor_message::nil;
        }
        op->message_size =
            strit - reinterpret_cast<unsigned char*>(&op->message);
    }
    }

    for (descriptors_size_type i = 0 ; i != op->descriptors_size ; ++i) {
        if (!op->descriptors[i].reference)
            continue;

        op->descriptors[i].value = *op->descriptors[i].reference;
        *op->descriptors[i].reference = INVALID_FILE_DESCRIPTOR;
    }
    op_started = true;
    op->do_wait();

    return lua_yield(L, 0);
}

inline int ipc_actor_chan_child_pid(lua_State* L)
{
    auto channel = static_cast<ipc_actor_address*>(lua_touserdata(L, 1));
    assert(channel);
    if (!channel->reaper) {
        push(L, std::errc::invalid_argument);
        return lua_error(L);
    }
#if BOOST_OS_LINUX
    lua_pushinteger(L, channel->reaper->childpid);
#else
    pid_t childpid;
    int res = pdgetpid(channel->reaper->childpidfd, &childpid);
    if (res == -1) {
        push(L, std::error_code{errno, std::system_category()});
        return lua_error(L);
    }
    lua_pushinteger(L, childpid);
#endif // BOOST_OS_LINUX
    return 1;
}

static int ipc_actor_chan_close(lua_State* L)
{
    auto channel = static_cast<ipc_actor_address*>(lua_touserdata(L, 1));
    if (!channel || !lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &ipc_actor_chan_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    if (!channel->dest.is_open()) {
        return 0;
    }

    channel->reaper = nullptr;

    boost::system::error_code ignored_ec;
    channel->dest.close(ignored_ec);
    assert(!ignored_ec);

    return 0;
}

static int ipc_actor_chan_detach(lua_State* L)
{
    auto& vm_ctx = get_vm_context(L);

    auto channel = static_cast<ipc_actor_address*>(lua_touserdata(L, 1));
    if (!channel || !lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &ipc_actor_chan_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    if (!channel->reaper) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    vm_ctx.pending_operations.erase(
        vm_ctx.pending_operations.iterator_to(*channel->reaper));
    delete channel->reaper;
    channel->reaper = nullptr;

    return 0;
}

static int ipc_actor_chan_kill(lua_State* L)
{
    lua_settop(L, 2);

    auto& vm_ctx = get_vm_context(L);

    auto channel = static_cast<ipc_actor_address*>(lua_touserdata(L, 1));
    if (!channel || !lua_getmetatable(L, 1)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }
    rawgetp(L, LUA_REGISTRYINDEX, &ipc_actor_chan_mt_key);
    if (!lua_rawequal(L, -1, -2)) {
        push(L, std::errc::invalid_argument, "arg", 1);
        return lua_error(L);
    }

    if (!channel->dest.is_open()) {
        push(L, errc::channel_closed);
        return lua_error(L);
    }

    if (!channel->reaper) {
        push(L, std::errc::operation_not_permitted);
        return lua_error(L);
    }

    switch (lua_type(L, 2)) {
    default:
        push(L, std::errc::invalid_argument, "arg", 2);
        return lua_error(L);
    case LUA_TNUMBER: {
        int signo = lua_tointeger(L, 2);
        if (signo == SIGKILL) {
            break;
        }

#if BOOST_OS_LINUX
        int res = syscall(SYS_pidfd_send_signal, channel->reaper->childpidfd,
                          signo, /*info=*/NULL, /*flags=*/0);
#else
        int res = pdkill(channel->reaper->childpidfd, signo);
#endif // BOOST_OS_LINUX
        if (res == -1) {
            push(L, std::error_code{errno, std::system_category()});
            return lua_error(L);
        }
        break;
    }
    case LUA_TNIL:
        break;
    }

    vm_ctx.pending_operations.erase(
        vm_ctx.pending_operations.iterator_to(*channel->reaper));
    channel->reaper->cancel();
    delete channel->reaper;
    channel->reaper = nullptr;

    boost::system::error_code ignored_ec;
    channel->dest.close(ignored_ec);
    assert(!ignored_ec);

    return 0;
}

static int ipc_actor_chan_mt_index(lua_State* L)
{
    auto key = tostringview(L, 2);
    if (key == "send") {
        rawgetp(L, LUA_REGISTRYINDEX, &ipc_actor_chan_send_key);
        return 1;
    } else if (key == "child_pid") {
        return ipc_actor_chan_child_pid(L);
    } else if (key == "close") {
        lua_pushcfunction(L, ipc_actor_chan_close);
        return 1;
    } else if (key == "detach") {
        lua_pushcfunction(L, ipc_actor_chan_detach);
        return 1;
    } else if (key == "kill") {
        lua_pushcfunction(L, ipc_actor_chan_kill);
        return 1;
    } else {
        push(L, errc::bad_index, "index", 2);
        return lua_error(L);
    }
}
#endif // BOOST_OS_UNIX

void init_actor_module(lua_State* L)
{
    lua_pushliteral(L, "spawn_vm");
    lua_pushcfunction(L, spawn_vm);
    lua_rawset(L, LUA_GLOBALSINDEX);

    lua_pushliteral(L, "spawn_context_threads");
    lua_pushcfunction(L, spawn_context_threads);
    lua_rawset(L, LUA_GLOBALSINDEX);

    lua_pushlightuserdata(L, &tx_chan_mt_key);
    {
        lua_createtable(L, /*narr=*/0, /*nrec=*/5);

        lua_pushliteral(L, "__gc");
        lua_pushcfunction(L, finalizer<actor_address>);
        lua_rawset(L, -3);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "tx-channel");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__newindex");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                push(L, std::errc::operation_not_permitted);
                return lua_error(L);
            });
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        lua_pushcfunction(L, tx_chan_mt_index);
        lua_rawset(L, -3);

        lua_pushliteral(L, "__eq");
        lua_pushcfunction(L, tx_chan_mt_eq);
        lua_rawset(L, -3);
    }
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &closed_tx_chan_mt_key);
    {
        lua_createtable(L, /*narr=*/0, /*nrec=*/4);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "tx-channel");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__newindex");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                push(L, std::errc::operation_not_permitted);
                return lua_error(L);
            });
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        lua_pushcfunction(L, closed_tx_chan_mt_index);
        lua_rawset(L, -3);

        lua_pushliteral(L, "__eq");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                push(L, std::errc::not_supported);
                return lua_error(L);
            });
        lua_rawset(L, -3);
    }
    lua_rawset(L, LUA_REGISTRYINDEX);

    lua_pushlightuserdata(L, &inbox_mt_key);
    {
        lua_createtable(L, /*narr=*/0, /*nrec=*/4);

        lua_pushliteral(L, "__gc");
        lua_pushcfunction(L, inbox_gc);
        lua_rawset(L, -3);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "rx-channel");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__newindex");
        lua_pushcfunction(
            L,
            [](lua_State* L) -> int {
                push(L, std::errc::operation_not_permitted);
                return lua_error(L);
            });
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        lua_pushcfunction(L, inbox_mt_index);
        lua_rawset(L, -3);
    }
    lua_rawset(L, LUA_REGISTRYINDEX);

#if BOOST_OS_UNIX
    lua_pushlightuserdata(L, &ipc_actor_chan_mt_key);
    {
        lua_createtable(L, /*narr=*/0, /*nrec=*/3);

        lua_pushliteral(L, "__gc");
        lua_pushcfunction(L, finalizer<ipc_actor_address>);
        lua_rawset(L, -3);

        lua_pushliteral(L, "__metatable");
        lua_pushliteral(L, "ipc_actor_channel");
        lua_rawset(L, -3);

        lua_pushliteral(L, "__index");
        lua_pushcfunction(L, ipc_actor_chan_mt_index);
        lua_rawset(L, -3);
    }
    lua_rawset(L, LUA_REGISTRYINDEX);
#endif // BOOST_OS_UNIX

    {
        lua_pushlightuserdata(L, &chan_send_key);
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(chan_op_bytecode), chan_op_bytecode_size,
            nullptr);
        assert(res == 0); boost::ignore_unused(res);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
        lua_pushcfunction(L, chan_send);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_type_key);
        lua_call(L, 3, 1);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }
    {
        lua_pushlightuserdata(L, &chan_receive_key);
        int res = luaL_loadbuffer(
            L, reinterpret_cast<char*>(chan_op_bytecode), chan_op_bytecode_size,
            nullptr);
        assert(res == 0); boost::ignore_unused(res);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
        lua_pushcfunction(L, chan_receive);
        rawgetp(L, LUA_REGISTRYINDEX, &raw_type_key);
        lua_call(L, 3, 1);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

    {
        lua_pushlightuserdata(L, &inbox_key);
        lua_newuserdata(L, sizeof(char));
        rawgetp(L, LUA_REGISTRYINDEX, &inbox_mt_key);
        setmetatable(L, -2);
        lua_rawset(L, LUA_REGISTRYINDEX);
    }

#if BOOST_OS_UNIX
    lua_pushlightuserdata(L, &ipc_actor_chan_send_key);
    rawgetp(L, LUA_REGISTRYINDEX, &var_args__retval1_to_error__key);
    rawgetp(L, LUA_REGISTRYINDEX, &raw_error_key);
    lua_pushcfunction(L, ipc_actor_chan_send);
    lua_call(L, 2, 1);
    lua_rawset(L, LUA_REGISTRYINDEX);
#endif // BOOST_OS_UNIX
}

} // namespace emilua

/* Copyright (c) 2020, 2021 Vin√≠cius dos Santos Oliveira

   Distributed under the Boost Software License, Version 1.0. (See accompanying
   file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) */

#include <string_view>
#include <charconv>
#include <optional>

#include <fmt/ostream.h>
#include <fmt/format.h>

#include <boost/preprocessor/stringize.hpp>
#include <boost/asio/io_context.hpp>
#include <boost/nowide/iostream.hpp>
#include <boost/nowide/args.hpp>
#include <boost/version.hpp>

#include <emilua/windows.hpp>
#include <emilua/state.hpp>

#if EMILUA_CONFIG_ENABLE_COLOR
#include <cstdlib>
#include <cstdio>

extern "C" {
#include <curses.h>
#include <term.h>
} // extern "C"
#endif // EMILUA_CONFIG_ENABLE_COLOR

namespace asio = boost::asio;
namespace hana = boost::hana;
namespace fs = std::filesystem;

static constexpr auto help_text = FMT_STRING(
    "Emilua: Execution engine for luaJIT\n"
    "Usage: {} [OPTIONS] [file]\n"
    "\n"
    "Positionals:\n"
    "  file TEXT                   Script filename\n"
    "\n"
    "Options:\n"
    "  -h,--help                   Print this help message and exit\n"
    "  --main-context-concurrency-hint INT\n"
    "                              Concurrency hint for the main execution engine context\n"
    "  --version                   Output version information and exit\n");

int main(int argc, char *argv[], char *envp[])
{
    LUAJIT_VERSION_SYM();
    std::optional<boost::nowide::args> args = std::nullopt;
    try {
        args.emplace(argc, argv, envp);
    } catch (const std::exception& e) {
        fmt::print(
            boost::nowide::cerr,
            FMT_STRING("Failed to read args/envp: `{}`\n"),
            e.what());
        return 2;
    }

    std::unordered_map<std::string_view, std::string_view> tmp_env;
    for (char** rawenv = envp ; *rawenv ; ++rawenv) {
        std::string_view env{*rawenv};
        auto i = env.find('=');
        auto key = env.substr(0, i);
        auto value = env.substr(i + 1);
        tmp_env.emplace(key, value);
    }

#if EMILUA_CONFIG_ENABLE_COLOR
    emilua::stdout_has_color = [&tmp_env]() {
        if (auto it = tmp_env.find("EMILUA_COLORS") ; it != tmp_env.end()) {
            if (it->second == "1") {
                return true;
            } else if (it->second == "0") {
                return false;
            } else if (it->second.size() > 0) {
                boost::nowide::cerr <<
                    "<4>Ignoring unrecognized value for EMILUA_COLORS\n";
            }
        }

        // Emilua runtime by itself will only ever dirt stderr
        if (!isatty(fileno(stderr)))
            return false;

        int ec = 0;
        if (setupterm(NULL, fileno(stderr), &ec) == ERR)
            return false;

        bool ret = tigetnum("colors") > 0;
        del_curterm(cur_term);
        return ret;
    }();
#else
    emilua::stdout_has_color = false;
#endif // EMILUA_CONFIG_ENABLE_COLOR

    if (auto it = tmp_env.find("EMILUA_LOG_LEVELS") ; it != tmp_env.end()) {
        std::string_view env = it->second;
        int level;
        auto res = std::from_chars(
            env.data(), env.data() + env.size(), level);
        if (res.ec == std::errc{})
            emilua::log_domain<emilua::default_log_domain>::log_level = level;
    }

    std::string_view filename;
    int main_ctx_concurrency_hint = BOOST_ASIO_CONCURRENCY_HINT_SAFE;
    emilua::app_context appctx;
    appctx.app_env = std::move(tmp_env);

#define NEXT_ARG(OPTION, LABEL) do {                                          \
        if (YYCURSOR = *++cur_arg ; YYCURSOR != nullptr) {                    \
            goto LABEL;                                                       \
        } else {                                                              \
            boost::nowide::cerr << "missing value for option `" OPTION "`\n"; \
            return 2;                                                         \
        }                                                                     \
    } while(0)

#define ERRARG(OPTION)                                                        \
    do {                                                                      \
        fmt::print(                                                           \
            boost::nowide::cerr,                                              \
            FMT_STRING("value `{}` not supported for option `" OPTION "`\n"), \
            *cur_arg);                                                        \
        return 2;                                                             \
    } while(0)

    /*!re2c
    re2c:define:YYCTYPE = char;
    re2c:yyfill:enable = 0;
    re2c:indent:string = "    ";

    end = "\x00";
    filename = [^\x00-][^\x00]*;
    */
    char* YYCURSOR;
    char* YYMARKER;
    char** cur_arg = argv;
opt:
    YYCURSOR = *++cur_arg;
    if (YYCURSOR == nullptr) goto end;
    %{
    * {
        fmt::print(boost::nowide::cerr, FMT_STRING("bad option: `{}`\n"),
                   *cur_arg);
        return 2;
    }
    "--" {end} {
        appctx.app_args.reserve(2 + ((argv + argc) - (cur_arg + 1)));
        appctx.app_args.emplace_back(argv[0]);
        appctx.app_args.emplace_back(filename);
        while (*++cur_arg) {
            appctx.app_args.emplace_back(*cur_arg);
        }
        goto end;
    }
    "-" {end} {
        boost::nowide::cerr << "stdin not supported as input file\n";
        return 2;
    }
    {filename} {end} {
        if (filename.size() > 0) {
            boost::nowide::cerr <<
                "emilua doesn't support more than one input file\n";
            return 2;
        }
        filename = *cur_arg;
        goto opt;
    }
    "-" { goto opt_short; }
    "--" { goto opt_long; }
    %}

opt_short:
    %{
    * {
        fmt::print(boost::nowide::cerr, FMT_STRING("bad short option: {}\n"),
                   *cur_arg);
        return 2;
    }
    {end} { goto opt; }
    "h" {
        fmt::print(boost::nowide::cout, help_text, *argv);
        return 0;
    }
    %}

opt_long:
    %{
    * {
        fmt::print(boost::nowide::cerr, FMT_STRING("bad long option: {}\n"),
                   *cur_arg);
        return 2;
    }
    "help" {end} {
        fmt::print(boost::nowide::cout, help_text, *argv);
        return 0;
    }
    "version" {end} {
        boost::nowide::cout << "Emilua " EMILUA_CONFIG_VERSION_STRING <<
            std::endl << LUAJIT_VERSION << std::endl <<
            "Boost " << (BOOST_VERSION / 100000) << '.' <<
            (BOOST_VERSION / 100 % 1000) << '.' << (BOOST_VERSION % 100) <<
            std::endl;
        return 0;
    }
    "main-context-concurrency-hint=" {
        *cur_arg = YYCURSOR;
        goto opt_main_context_concurrency_hint;
    }
    "main-context-concurrency-hint" {end} {
        NEXT_ARG("--main-context-concurrency-hint",
                 opt_main_context_concurrency_hint);
    }
    %}

opt_main_context_concurrency_hint:
    %{
    * { ERRARG("--main-context-concurrency-hint"); }
    "1" {end} {
        main_ctx_concurrency_hint = 1;
        goto opt;
    }
    "safe" {end} {
        main_ctx_concurrency_hint = BOOST_ASIO_CONCURRENCY_HINT_SAFE;
        goto opt;
    }
    %}
end:

    if (filename.size() == 0) {
        boost::nowide::cerr << "missing filename\n";
        return 2;
    }

    if (appctx.app_args.size() == 0) {
        appctx.app_args.reserve(2);
        appctx.app_args.emplace_back(argv[0]);
        appctx.app_args.emplace_back(filename);
    }

#if EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 2
    asio::io_context ioctx{main_ctx_concurrency_hint};
    asio::make_service<emilua::properties_service>(
        ioctx, main_ctx_concurrency_hint);
#elif EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 1
    asio::io_context ioctx{1};
    asio::make_service<emilua::properties_service>(ioctx, 1);
#elif EMILUA_CONFIG_THREAD_SUPPORT_LEVEL == 0
    asio::io_context ioctx{BOOST_ASIO_CONCURRENCY_HINT_UNSAFE};
    asio::make_service<emilua::properties_service>(ioctx, 1);
#else
# error Invalid thread support level
#endif

    if (
        auto it = appctx.app_env.find("EMILUA_PATH") ; it != appctx.app_env.end()
    ) {
        for (std::string_view spec{it->second} ;;) {
            std::string_view::size_type sepidx = spec.find(
#if BOOST_OS_WINDOWS
                ';'
#else
                ':'
#endif
            );
            if (sepidx == std::string_view::npos) {
                appctx.emilua_path.emplace_back(
                    emilua::widen_on_windows(spec), fs::path::native_format);
                appctx.emilua_path.back().make_preferred();
                break;
            } else {
                appctx.emilua_path.emplace_back(
                    emilua::widen_on_windows(spec.substr(0, sepidx)),
                    fs::path::native_format);
                appctx.emilua_path.back().make_preferred();
                spec.remove_prefix(sepidx + 1);
            }
        }
    }

    appctx.emilua_path.emplace_back(
        emilua::widen_on_windows(EMILUA_CONFIG_LIBROOTDIR),
        fs::path::native_format);
    appctx.emilua_path.back().make_preferred();
    // TODO: Remove VERSION_MINOR from path components once emilua reaches
    // version 1.0.0 (versions that differ only in minor and patch numbers do
    // not break API).
    appctx.emilua_path.back() /=
        "emilua-" BOOST_PP_STRINGIZE(EMILUA_CONFIG_VERSION_MAJOR)
        "." BOOST_PP_STRINGIZE(EMILUA_CONFIG_VERSION_MINOR);

    try {
        auto vm_ctx = emilua::make_vm(ioctx, appctx,
                                      emilua::widen_on_windows(filename),
                                      emilua::ContextType::main);
        appctx.master_vm = vm_ctx;
        vm_ctx->strand().post([vm_ctx]() {
            vm_ctx->fiber_resume(
                vm_ctx->L(),
                hana::make_set(
                    emilua::vm_context::options::skip_clear_interrupter));
        }, std::allocator<void>{});
    } catch (std::exception& e) {
        boost::nowide::cerr << "Error starting the lua VM: " << e.what() <<
            std::endl;
        return 1;
    }

    ioctx.run();

    {
        std::unique_lock<std::mutex> lk{appctx.extra_threads_count_mtx};
        while (appctx.extra_threads_count > 0)
            appctx.extra_threads_count_empty_cond.wait(lk);
    }

    return appctx.exit_code;
}

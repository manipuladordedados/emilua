+++
title = "tls.socket"
+++

[source,lua]
----
tls_ctx = tls.ctx.new('tlsv13')

local resolver = ip.tcp.resolver.new()
local addr = resolver:resolve('www.example.com', '')[1].ep_addr

local s = ip.tcp.socket.new()
s:connect(addr, 443)
s = tls.socket.new(s, tls_ctx)
s:client_handshake()
s = http.socket.new(s)

local req = http.request.new()
local res = http.response.new()
req.headers.host = 'www.example.com'

s:write_request(req)
s:read_response(res)
----

== Functions

=== `new(sock: ip.tcp.socket, tls_ctx: tls.ctx) -> tls.socket`

Constructor.

=== `client_handshake(self)`

Perform the TLS client handshake and suspend current fiber until operation
finishes.

=== `server_handshake(self)`

Perform the TLS server handshake and suspend current fiber until operation
finishes.

=== `read_some(self, buffer: byte_span) -> number`

Read data from the stream socket and blocks current fiber until it completes or
errs.

Returns the number of bytes read.

=== `write_some(self, buffer: byte_span) -> number`

Write data to the stream socket and blocks current fiber until it completes or
errs.

Returns the number of bytes written.

=== `write(self, buffer: byte_span) -> number`

Write all of the supplied data to the stream socket and blocks current fiber
until it completes or errs.

Returns the ``buffer``'s size (number of bytes written).

https://www.boost.org/doc/libs/1_77_0/doc/html/boost_asio/reference/async_write/overload1.html[As
in Boost.Asio]:

[quote]
____
This operation is implemented in terms of zero or more calls to the stream's
async_write_some function, and is known as a _composed operation_. The program
must ensure that the stream performs no other write operations (such as
async_write, the stream's async_write_some function, or any other composed
operations that perform writes) until this operation completes.
____
